\documentclass{jsarticle}
\title{情報科学演習C 第2回レポート課題} % 題目
\author{谷村亮介}                    % 提出者名
\date{平成25年7月4日(木)}            % 提出日

% \課題名{ネットワークプログラミングの基礎}   % 課題名
% \担当教官{内山彰}                       % 担当教官名
% \所属{ソフトウェア科学コース}             % 自分の所属するコース名などを指定する.
% \学年{3年}                             % 学年
% \学籍番号{09B11044}                    % 学籍番号
% \email{u549298j@ecs.osaka-u.ac.jp}    % 電子メールのアドレス

\usepackage{ascmac}
\usepackage{here}
\usepackage{txfonts}
\usepackage{listings, jlisting}
\usepackage{color}
\usepackage[dvips]{graphicx}


\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{colFunc}{rgb}{1,0.07,0.54}
\definecolor{CadetBlue}{cmyk}{0.62,0.57,0.23,0}
\definecolor{Brown}{cmyk}{0,0.81,1,0.60}
\definecolor{colID}{rgb}{0.63,0.44,0}


\renewcommand{\lstlistingname}{リスト}
\lstset{language=c,
  backgroundcolor={\color[gray]{.95}},%
  basicstyle=\sffamily\scriptsize,
  keywordstyle={\bfseries \color{OliveGreen}},
  commentstyle={\itshape \color{Brown}},
  stringstyle={\ttfamily \color{CadetBlue}},
  frame=tRBl,
  framesep=5pt,
  showstringspaces=false,
  numbers=left,
  stepnumber=1,
  numberstyle=\sffamily\tiny,
  tabsize=2
}

\begin{document}
\tableofcontents
\newpage



\section{課題内容}

\subsection{課題4-1}

手順書3章に示されたプロトコル仕様にしたがってチャットプログラム
(クライアントおよびサーバプログラム) を作成する。
作成したチャットプログラムは、サンプルプログラムとの通信が正しくできなければならない。

\subsection{課題4-2}

chatserver、chatclient を拡張し、
便利と思われる機能を追加する。

今回追加した機能は以下のとおりである。

\begin{itemize}
\item 各発言の先頭にユーザ名以外に、発言時刻が表示される機能
\item サーバへ"\verb+/list\n+"という文字列を送ると
  現時点の全参加者のユーザ名リストが返されるという機能
\item [難] 一定時間発言のないユーザを強制離脱させる機能
\end{itemize}


\section{解答 -- 課題4-1・課題4-2 -- }

\subsection{実装方法  -- chatclient.c --}
\label{semop}
このプログラムの実装方法を以下に示す。
なお、各段落の見出しは、付録に示したソースコード中の同じ文に該当する。
これ以降の「実装方法」の章でも同じ記述方法を採用している。


\paragraph{c1 初期状態}
まず始めに引数の数を確認する。
正しく動作させるためにはプログラムに2つの引数を与える必要があるので、
それ以外の時はエラーメッセージを出力してプログラムを終了する。

次に、サーバーと通信するためのソケットを作成する。
プロトコルにはTCPを選択し、使用するポートには10140を指定する。

第1引数の文字列からIPアドレスを取得し、
サーバーに接続する。
接続が確立できたら、次の状態に移る。


\paragraph{c2 参加}
サーバーから文字列を受信し、
それが``\verb+REQUEST ACCEPTED\n+''であるかを確認する。
サーバーから送られてきた文字列にはヌル文字が含まれていないため、
strncmp()を用いて、ヌル文字以外を比較する必要がある。

サーバーから送られてきた文字列が
``\verb+REQUEST ACCEPTED\n+''であれば、
それを標準出力に出力し、次の状態に移る。
それ以外であれば、エラーが発生したことを通知するとともに、
受信した文字列を標準出力に出力し、状態c6に移る。


\paragraph{c3 ユーザー名登録}
サーバーにユーザー名を送信するために、
まずは第2引数に与えられた文字列を加工する。
引数の文字列を作業用の変数nameにコピーし、
nameの末尾に``\verb+\n+''を付加する。
そして、write()でサーバーに送信する。

状態c2の場合と同様にして、
サーバーから返ってきた文字列が
``\verb+USERNAME REGISTERED\n+''
であるか確認する。
そうであれば、次の状態に移り、
異なる場合は状態c6に移る。

なお、プロトコル仕様では、
「ユーザ名は英数字、ハイフン (``-'') およびアンダースコア (``\_'') のみから成る文字列とする」
と規定されている。
このプログラムでは、ユーザー名が仕様に従っているかは判定せず、
必ず正しいユーザー名が入力されると仮定して処理を行なっている。
もし誤ったユーザー名が入力されても受理してしまうが、
この性質はサンプルクライアントでも同様であったから、
今回は問題にならないはずである。


\paragraph{c4 メッセージ送受信}
サーバーへのユーザー名登録が完了したら、
全2重通信を利用してチャットの動作を開始する。

標準入力と、作成したソケットを、
入力を監視するファイル記述子として、
変数rfdsにセットする。
監視する待ち時間は1秒に設定する。

次に、select()を用いて、
標準入力とソケットからの受信を同時に監視する。
標準入力から入力があった時は、
rfdsの中に0がセットされている。
FD\_ISSET()を用いると、これを確認することができる。
この時には標準入力から文字列を読み込み、
そのままサーバーに送信する。

同様にして、ソケットから確認したことがわかったら、
ソケットから文字列を読み込み、
そのまま標準出力に出力する。

EOFを読み込むまでこの作業を繰り返し実行すると、
チャットクライアントとしての機能を得ることができる。


\paragraph{c5 離脱}
read()で文字列を読み取った結果、
それがEOFであれば、返り値が0になる。
この場合は状態c4のループを抜け、
ソケットをcloseしてプログラムを終了する。


\paragraph{c6 例外処理}
状態c2およびc3で、正しい文字列を受信できなかった時には、
exception()関数が呼び出される。
この関数は、ソケットをcloseした後エラーメッセージを出力し、
プログラムを強制終了する。


\subsection{実装方法 -- chatserver.c --}

まず、プロトコル使用で要求された部分の実装方法を示し、
課題4-2の拡張の実装方法は、後半でまとめて示す。


\paragraph{s1 初期状態}
まずは、クライアント情報を記録するリストを初期化する。
今回は、クライアントのソケットとユーザー名をまとめて扱うために、
memList構造体を作成した。
この構造体を、配列list[]として\verb+MAXCLIENT+の個数分作成し、
配列の要素が空であることを示すために、
csockに-1を入れておく。
参加クライアント数k=0とする。
なお、参加者を管理するために配列ではなく単方向リストなどを用いる方法も考えられるが、
今回は実装のシンプルさを優先して、配列で管理することにした。

次に、ユーザーのタイムアウト機能のために使用するパイプを生成しておく。

クライアントの場合と同様にして、
クライアントを受け付けるためのソケットを生成する。
プロトコルはTCP、使用ポートは10140である。
待ち受けクライアント数の最大値は、
\verb+MAXCLIENTS+としておいた。

ソケットを作成できたら、
次の状態に移る。


\paragraph{s2 入力待ち}
FD\_SET()で、タイムアウト用パイプ、
クライアント受付用ソケット、参加者のソケットを
集合rfdsに追加する。
参加者のソケットを追加する際には、
配列の要素が空でないもの、すなわちcsockの値が-1でないものを追加する。

select()を用いて、ソケットとパイプからの受信を同時に監視する。
この関数の第1引数には、rfdsに追加された値の最大値+1を指定する必要があるが、
今回は十分大きい値と考えられる10を指定した。

ここで注意しなければならないことは、
select()が実行された結果、
rfdsの値は書き換えられてしまうため、
毎回rfdsの値をセットし直さなければならないということである。

\paragraph{s3 入力処理 }
FD\_ISSET()を使って入力があったソケットを判別し、
入力があったすべてのソケットとパイプに対して入力処理を行う。

接続要求があった場合は状態s4に、
クライアントから入力があった場合は状態s5に移る。


\paragraph{s4 参加受付}
接続要求があったときには、
接続をaccept()する。
現在の参加クライアント数kの値が\verb+MAXCLIENTS+よりも大きかった場合は、
``\verb+REQUEST REJECTED\n+''
をクライアントに送信し、ソケットを閉じる。
そうでない時は、
``\verb+REQUEST ACCEPTED\n+''
を送信し、次の状態に移る。

\paragraph{s5 ユーザー名登録}
クライアントからはユーザー名が返ってくるはずなので、
これを読み取る。
受信した文字列の末尾には\verb+\n+があるので、
それを\verb+\0+に置き換える。
この時点では、ユーザー名の文字数が異常に長い場合がある。
そこで、\verb+MAXNAME+番目の文字も\verb+\0+に置き換えることによって、
長すぎる部分を無視する。
サンプルサーバーではユーザー名の最大値は99であったが、
今回は\verb+NAXNAME+=20とした。
その後、ユーザー名を作業用の変数にコピーする。

ユーザー名の文字列処理の過程の例を、以下に示す。

\begin{screen}
\begin{verbatim}
rbuf = ABCDEFGHIJKLMNOPQRSTUXYZ\n
  ↓ \nを\0に置き換え
rbuf = ABCDEFGHIJKLMNOPQRSTUXYZ\0
  ↓ 21文字目を\0に置き換え
rbuf = ABCDEFGHIJKLMNOPQRST\0XYZ\0
  ↓ unにコピー
un   = ABCDEFGHIJKLMNOPQRST\0
\end{verbatim}
\end{screen}

続いて、同一のユーザー名がすでに登録されているかどうかを
確認する。
strcmp()を用いて、list[].nameの中身と1つづつ比較していき、
同じユーザー名が存在する場合にはフラグを立てる。

フラグがたった時には、
``\verb+USERNAME REJECTED\n+''
をクライアントに送信し、
ソケットを閉じる。
フラグが立っていないときには、
``\verb+USERNAME REGISTERED\n+''
を送信する。
list[]の開いている部分、
すなわちlist[].csock=1の部分を探し、
そこにソケットとユーザー名を記録する。

最後にkの値を1増やし、
状態s3に戻る。

\paragraph{s6 メッセージ配信}
登録したクライアントのどれかからメッセージを受信した時には、
その文字列を読み込む。
EOFが送られてきた時、
すなわちread()の返り値nbytesの値が0の時には、
状態s7に移行して、クライアントを離脱させる。

文字列が送られてきたときには、
登録されている全てのクライアントに対して、
発信したユーザー名と文字列を送信する。

その後状態s3に戻る。

\paragraph{s7 離脱処理}

離脱処理については、
sockClose()関数にまとめてある。
引数に指定されたソケットをcloseし、
リストの値を-1にしておく。
これにより、その部分が空であることが示される。
list[].nameの値は空白にしておく。
最後にクライアント数kの値を1減らし、
処理を完了する。

ここで、listの消去と書き込み処理について具体的に示す。

\begin{screen}
\begin{verbatim}
list[0].csock = 4     list[0].csock = 4     list[0].csock = 4
list[1].csock = 5     list[1].csock = 5     list[1].csock = 5
list[2].csock = 6  -> list[2].csock = -1 -> list[2].csock = 8
list[3].csock = 7     list[3].csock = 7     list[3].csock = 7
list[4].csock = -1    list[4].csock = -1    list4[].csock = -1
\end{verbatim}
\end{screen}

listの中身が、上の例の左側のようになっている場合を考える。
この状態からlist[2].csockが離脱した場合、
この値が書き換えられて真ん中のようになる。
この状態において、新たにクライアントを受け付けると、
右側のように、最初の空き部分であるlist[2].csockに追加される。
このようにすることで、単方向リストなどを用いなくても、
クライアントの参加・離脱処理を正しく行うことができる。


\paragraph{[発展]現在時刻の表示}
現在時刻を取得するために、
getTime()関数を作成した。
この関数は、現在時刻を(時間:分:秒)の形式にして、
引数に与えられた文字列に書き込む関数である。

time()で現在の時刻を取得し、
localtime()でローカルタイムに変換する。
strftime()を使うと、現在時刻を指定したフォーマットに変換することができる。

プログラムの199行目で、getTime(str)を呼び出し、
現在時刻が書き込まれた文字列strを、
204行目でクライアントに対して送信する。
それに続けてユーザー名やメッセージを送信すれば、
メッセージの先頭に現在時刻を表示することができる。

\paragraph{[発展]参加者一覧の表示}
186行目で、クライアントから受信したメッセージが``\verb+/list\n+''であるかを判定する。
一致した場合は、list[].nameの中身を順に送信していく。
表示順序は、参加した順やアルファベット順ではなくlistに保存された順番となる。
このようにすれば、
``\verb+MEMBERS -> memA memB memC\n+''
のような文字列が、クライアントに対して送信される。

\paragraph{[発展]一定時間発言のないユーザーのタイムアウト}

タイムアウト機能を実現するために、
課題3で作成したmyalarm()関数を一部改造して使用した。

今回は接続された複数のクライアントに対してそれぞれタイマーをセットする必要がある。
そこで、myalarm()の第1引数に、
監視するべきクライアントを指定することにした。
一定時間が経過すると、パイプにソケット番号が書き込まれ、
その書き込みをmain()関数のselect()で検知し、
書き込まれたソケットに対して離脱処理をする、
という流れでタイムアウト処理を行なっている。

myalarm()の実装方法について詳しく説明する。
まずは、タイマー用の子プロセスを生成する。
子プロセスは、第3引数で指定された秒数待機し、
親プロセスがまだ存在していることを確認して、
第2引数で指定されたパイプに、クライアント番号を書き込む。
クライアント番号とは、第1引数で指定された値であり、
list[]の添字部分である。
親プロセスの存在を確認してからパイプへの書き込みを行わないと、
サーバーがctrl+Cで強制終了した後に書き込みエラーが発生してしまう。

親プロセスは、すでに動作している子プロセスが存在するときにはそれを消去する。
前の子プロセスのPIDはoldPid[]というグローバル変数に保存されている。
そして、今回作成した子プロセスのPIDをoldpid[]に控えておく。
子プロセスがゾンビプロセスになるのを防ぐために、
\verb+SIGCHLD+というシグナルを無視する設定にして、
myalarm()を終了する。

パイプに値が書き込まれた時には、
264行目でそれを検知することができる。
パイプの値を読み込み、
該当するソケットに対してタイムアウトが起こったことを通知し、
sockClose()で離脱処理を行う。

アラームをセットするタイミングは、
クライアントの参加を受け付けた直後と、
クライアントからメッセージを受信した直後である。
こうすることで、一定時間発言のない場合に、
クライアントを離脱させることができる。
なお、タイムアウトまでの時間は
定数\verb+TIMEOUT+で定義されている。


\subsection{実行結果}

\begin{screen}
\begin{verbatim}
% ./filecounter.exe
count = 1
count = 2
count = 3
count = 4
% cat counter
4
% ./filecounter.exe
count = 1
count = 2
count = 3
count = 4
% cat counter
4
\end{verbatim}
\end{screen}


\subsection{考察}
このプログラムにとりかかる時、
セマフォの仕組み自体を理解するのは容易であったが、
C言語での実装は、やや癖があり、正しく実装することが難しかった。
これに対しては、
セマフォを操作するための関数を自分で用意したことで、
より簡単に操作をすることが可能になった。
自分が操作したい内容に応じて関数をカスタマイズすることで、
より使いやすいセマフォ操作を実現することが出来た。
今後、このような新たな機能を利用するときには、
積極的に関数化し、自分にとって扱いやすいものにしていくことが重要だと考えられる。

今回セマフォを使用していて疑問に思ったことは、
セマフォのインクリメントやデクリメントもクリティカルセクションに該当するのではないのか、
ということである。
これについて詳しく調べてみると、
セマフォのインクリメントなどには、
「デッカーのアルゴリズム」などの排他制御アルゴリズムが用いられているようであった。
このように、適切な排他制御が行われているため、
セマフォを使えばシンプルなWAIT、SIGNAL命令だけで排他制御を行うことができるのである。
今後、プロセス間で排他制御を行う際には、
セマフォを積極的に利用して行きたいと思った。


\section{発展課題}

\subsection{課題内容}

ソケット通信機能が利用できる他の言語 (Java,perl など) で、
chatclient(もし可能ならchatserverも) を作成し、
C 言語で作成したものと混在させて通信させる。

今回は、

\begin{itemize}
\item perlで実装したクライアント「chatclient.pl」
\item rubyで実装したクライアント「chatclient.rb」
\item rubyで実装したサーバー「chatserver.rb」
\end{itemize}

の3つのプログラムを作成した。

課題4-2の拡張は施しておらず、
各プログラムの仕様は、指導書のプロトコル仕様と同じである。


\subsection{実装方法 -- chatclient.pl --}
プログラムの流れは課題4-1のクライアントプログラムとほとんど変わらないため、
C言語での実装と比べて異なる部分や、
特徴的な部分に着目して、実装方法を示していく。
発展課題の他のプログラムにおいても同様である。

perlでソケットを使用する場合は、
Socketモジュールが必要なので、
最初に読み込んでおく。

ソケット作成の手順は、
C言語の場合と少し似ている。
この部分の設定は、
参考文献[1]を参考にした。
\$hostの値を第1引数から取得し、
\$portの値は10140に設定する。
connect()によって、サーバーと接続することができる。
エラー処理を行う場合は、
``\verb+or die "$!"+''と書けば
C言語のperror()を同じ処理を行うことができる。
ソケットに対しては、書き込みバッファリングを行わない設定を行なっておく。

ソケットからデータを読み込む際には、
``\verb+rbuf = <$sock>+''
とするだけで良い。
文字列を比較する際には、eq演算子を用いる。
C言語と異なり、
末尾の\verb+\0+を気にする必要はない。

``\verb+print $sock "$ARGV[1]"."\n";+''
とすれば、第2引数の末尾に\verb+\n+を結合して
サーバーにユーザー名を送信することができる。
標準出力に出力する場合と同じように出力できるため、
C言語とくらべてデータの送信は容易である。

全2重通信を実現するためには、
4引数のselect()関数を用いる。
この関数は、第1・2・3引数にそれぞれ、
入力・出力・例外を監視するファイルディスクリプタの集合を与え、
第4引数に待機時間(sec)を与える。
今回は入力のみを監視したいので、第2・3引数はundefとしている。
ファイルディスクリプタの集合を表すためにはビット列を用いる。
例えば、ファイルディスクリプタ1番と4番と5番を監視したいときには、
\$rfdsの1・4・5ビット目を1にして、
``\verb+$rfds = 00110010+''
となる。

select()を実行すると、\$rfdsの値が\$routにコピーされ、
入力の状態に応じて\$routの値が書き換えられる。
例えば、ファイルディスクリプタ4番と5番から入力があった場合には、
``\verb+$rout = 00110000+''
となっているから、
\$routのビット列を読み取れば、
どのファイルディスクリプタから入力があったかが分かる。

perlでビット列を操作する場合は、
vec()関数を用いる。
``\verb+vec($rfds, X, Y) = 1+''
とすれば、\$rfdsのXビット目からYビット分を1にすることができる。
``\verb+vec($rout, X, Y)+''
とすれば、\$routのXビット目からYビット分の値を取り出すことができる。
このようにして、ビット値の書き込みと読み込みを行う。
また、ファイルディスクリプタの番号を調べるためには、
fileno()関数を用いている。

標準入力やソケットからデータを受信したことがわかったら、
<>を使ってデータを読み込み、
サーバーや標準入力にprintする。
EOFが送られてきた時には、
読み取りの結果が空文字列になるので、
この時はソケットを閉じてプログラムを終了する。
EOFの判定はC言語の場合よりもわかりやすい。

select()の処理を無限ループで繰り返せば、
引き続きメッセージ送受信を行うことができる。

\subsection{実装方法 -- chatclient.rb --}

Rubyでソケットを利用するには、
socketライブラリをrequireする必要がある。

ソケットの生成は、
C言語やPerlに比べると極めて簡単である。
``\verb+sock = TCPSocket.open(ARGV[0], 10140)+''
とするだけで、
第1引数に指定されたホストに対して、ポート番号10140を使って接続することができる。
エラー処理を書かなくても、適切なエラーを自動的に出してくれる。
例えば、ホストが見つからない時やサーバーが見つからないときには、
対応するエラーメッセージを出力してプログラムが強制終了する。
上手く接続出来れば、sockオブジェクトが生成される。

ソケットから受信したデータの読み取りは、
\verb+sock.gets+で、
ソケットへのデータ受信は
\verb+sock.print+で行う。

ユーザー名登録などの処理は実装が簡単なため、
説明は省略する。

全2重通信の実装は、
IO.select()メソッドを用いる。
このメソッドは入力・出力・例外を監視することができるが、
今回は入力のみを監視したいため、引数を1つだけ与える。
第1引数に入力を監視したいファイルディスクリプタの配列を与えると、
入力があるまで監視を続け、
入力があれば、そのファイルディスクリプタが配列として
rfds[0]に格納される。
``\verb+rfds[0].each do |d|+''とすることで、
rfds[0]の中身を1つずつ取り出すことができる。
その後、case文で処理を分岐する。

``\verb+STDIN.eof?+''
とすれば、入力がEOFかどうかがわかるので、
入力を読み取ってソケットに書き込む。
入力がEOF入力がだった場合は、
ソケットを閉じてexitでプログラムを終了する。
ソケットから受信した場合も処理は同様である。

IO.select()での監視を無限ループで繰り返せば、
メッセージの送受信を続けることができる。


\subsection{実装方法 -- chatserver.rb --}

サーバー用のソケットを作成する方法も、極めて簡単である。
``\verb+server = TCPServer.new(10140)+''
という一行の記述のみで良い。

Rubyによるサーバーの実装では、
クライアントのソケットとユーザー名を管理するために、
2つの配列csock[]とcname[]を使用した。
Rubyでは2次元配列や構造体の扱いがやや複雑であったため、
今回は独立した配列を使用している。

全2重通信の方法は、クライアントの場合と同様である。
サーバーへの接続要求と各クライアントからのデータ受信を監視するために、
serverを配列化し、それをcsock[]と結合したものを、
IO.select()の引数に与えている。

クライアントからの接続要求があった時には、
それをacceptする。
現在の接続クライアント数は、
csock[]の要素数に等しい。
したがって、csock.sizeの値に応じて、
接続要求を受け入れるかどうかを判別すれば良い。

クライアントから送られてくるユーザー名の末尾には、
\verb+\n+が付加されているため、chompでそれを取り除く。
同じユーザー名がすでに存在するかどうかを判定するためには、
``\verb+cname.index(un)+''
とすれば、cnameの全ての要素に対して検索を実行することができる。
同一ユーザー名が存在しない場合には、
クライアントのソケットとユーザー名を、
csock[]とcname[]にpushする。
こうすることで、
配列の末尾にデータを追加することができる。

クライアントから受信した時には、
繰り返し構文を用いて、
全てのクライアントにメッセージを送信する。
メッセージの送信にはprint()を使うので、
先頭にユーザー名を付加するような文字列加工も容易である。

ここでは、クライアントの場合と同様の方法で、
受信したデータがEOFであるかどうかを判定している。
EOFであった場合は、
csock[]とcname[]の該当するデータを削除し、
ソケットをcloseする。
``\verb+i = csock.index(sock)+''
とすれば、sockが入っている部分の添字番号を取得できる。
これを利用して、その部分のデータを除去する。
``\verb+csock.delete_at(i)+''
とすれば、i番目の要素が除去され、
配列の要素数は1つ減る。
つまり、
[1, 3, 5, 6]という配列の2番目を除去した場合、
配列は[1, 5, 6]になる。
これによって、単方向リストを用いた時のような操作を簡単に行うことができる。
このおかげで、
C言語の場合と比べてクライアントの追加・除去が容易になっている。

以上の動作を無限ループで繰り返せば、
サーバーの機能を実装することができる。

\subsection{実行結果}
two-way-pipe.exeを数回実行した結果を以下に示す。

\begin{screen}
\begin{verbatim}
% ./two-way-pipe.exe FROMCHILD FROMPARENT
Message from Parent process:    FROMPARENT
Message from child process:     FROMCHILD
$ ./two-way-pipe.exe FROMCHILD FROMPARENT
Message from child process:     FROMCHILD
Message from Parent process:    FROMPARENT
\end{verbatim}
\end{screen}


このプログラムを実行した結果、
親子間で正しくメッセージをやりとりできている。
また、何回か実行すると、親の処理が先に実行されていたり、
子の処理が先に実行されていたりすることから、
親プロセスと子プロセスの処理は同時に実行されていることがわかる。

従って、このプログラムは仕様を満たしている。

\subsection{考察}

\subsubsection{Perlでの実装について}

C言語でサーバー・クライアントプログラムを作成していた際には、
文字列処理の煩雑さにうんざりさせられた。
そこで発展課題では、文字列処理に適したPerlを用いて
クライアントプログラムを作成してみることにした。
また、ソケットを用いれば異なる言語で書かれたプログラムであっても
正しく通信を行うことができるということも確認する。

Perlを用いた実装では、
予想通り、C言語での実装よりも簡潔にプログラムを記述することが出来た。
C言語では面倒であったヌル文字を扱う必要はなく、
文字列比較は単純に``eq''演算子で行うことができる。
また、文字列の結合も容易である。
例外処理も、die()を使うことで簡潔に書くことができる。

C言語では、ソケット通信のために低水準な入出力関数read()やwrite()を用いる必要があったが、
Perlの場合は端末に入出力する時と同様に、<>やprint関数を使えばいいので、
データのやり取りも簡単である。

全2重通信は、C言語の場合と同じようにして実装することが出来た。
ビット列の操作は最初は若干戸惑ったが、
printデバッグのためにはこちらのほうが都合が良かった。

実際に通信を行なってみると、
C言語で作成したサーバーと正常にチャットを行うことが出来た。
プロトコル仕様をきちんと定めておけば、
言語や環境に依存することなく、
異なるプログラム間の通信が実現できるということがわかった。

\subsection{Rubyでの実装について}

ここまでのプログラムで感じたことは、
ソケットを作成する際の記述の多さである。
決まりきった命令列ではあるが、
ソケットを作成する際にはいくつかの設定を行わなくてはならない。
そこで、ソケットを簡単に作成できる言語を探してみたところ、
Rubyでは、たった1行の記述でTCPソケットを作成することができるということがわかった。
例外処理を自分で記述しなくても、
自動的に適切なエラーメッセージを出力してくれる。

Rubyの特徴は、
オブジェクト指向の言語だということである。
ソケットを生成すれば、それに対して色々なメソッドを適応していく形で
処理を実行できる。
Rubyでクライアントプログラムを作成してみたところ、
やはりC言語の場合よりも簡単に記述することが出来た。
文字列の取得・加工・比較などはPerlのように簡単に行うことができる。
受信した文字列がEOFかどうか判定するためには、
専用のメソッドが用意されているため、
この判定は他の言語よりもわかりやすい。

全2重通信には、こちらもselectという名前のメソッドを用いる。
第1引数に入力を監視したいファイルディスクリプタを配列として与えると、
入力があったファイルディスクリプタが配列として返ってくる。
今回用いたselectの中では、これが一番直感的でわかりやすいと感じた。

Rubyでプログラムを行なっていると、
配列を処理するためのメソッドが充実していることに気づいた。
これを活用すればサーバーの実装も用意になるのではないかと考え、
実際に実装してみた。
Rubyでは、配列へのデータの「挿入」や、
データの「除去」を簡単に行うことができるため、
クライアントの参加・離脱処理を簡単に実装することができた。
この結果、完全なサーバープログラムをたったの60行で記述することができた。
拡張を施していないC言語での実装と比べると、
行数比較で1/3の記述量である。
このおかげで、プログラムの可読性は飛躍的に向上した。
課題4-2のような拡張を施すことも容易だと考えられる。


\subsubsection{まとめ}

今回の発展課題を通して、
C言語以外の言語でもソケットプログラムを作成できるということや、
ソケットを使用すれば、異なる言語で書かれたプログラム間の通信も
簡単に行えるということを学ぶことができた。
また、同じ動作をするプログラムを複数の言語で記述することで、
それぞれの言語の特徴も把握することができた。

C言語は、プログラムの細かい挙動まで自分で設定できる反面、
文字列の処理が煩雑になってしまう。
ソケットプログラミングの基本を理解するためには最適であるが、
文字列処理の面で言えば、PerlやRubyのような言語を使うほうが、
簡潔で確実な記述を行うことができる。

今回用いた3つの言語の中で最もプログラムしやすいと感じたのは、
Rubyである。
ソケットの細かい挙動を気にしなくてもプログラミングできるのは、
オブジェクト指向言語の大きな利点である。
3つの言語の中で最もわかりやすく、簡潔なプログラムを書くことができた。

ソケットプログラムの利点は、
プロトコル仕様にさえ従えば、
どのような実装をしても良い、ということである。
処理内容に応じて、適切な言語を選択すれば、
よりプログラムの効率が向上するであろう。

\section{感想}




%\lstinputlisting[caption=mergesortPipe.c,label=mg]


\end{document}