\documentclass{icsreport}

\title{情報科学演習C 第2回レポート課題} % 題目
\author{谷村亮介}                    % 提出者名
\date{平成25年5月20日(木)}            % 提出日

\課題名{ネットワークプログラミングの基礎}   % 課題名
\担当教官{内山彰}                       % 担当教官名
\所属{ソフトウェア科学コース}             % 自分の所属するコース名などを指定する.
\学年{3年}                             % 学年
\学籍番号{09B11044}                    % 学籍番号
\email{u549298j@ecs.osaka-u.ac.jp}    % 電子メールのアドレス

\usepackage{ascmac}
\usepackage{here}
\usepackage{txfonts}
\usepackage{listings, jlisting}
\usepackage{color}
\usepackage[dvips]{graphicx}


\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{colFunc}{rgb}{1,0.07,0.54}
\definecolor{CadetBlue}{cmyk}{0.62,0.57,0.23,0}
\definecolor{Brown}{cmyk}{0,0.81,1,0.60}
\definecolor{colID}{rgb}{0.63,0.44,0}


\renewcommand{\lstlistingname}{リスト}
\lstset{language=c,
  backgroundcolor={\color[gray]{.95}},%
  basicstyle=\sffamily\scriptsize,
  keywordstyle={\bfseries \color{OliveGreen}},
  frame=tRBl,
  framesep=5pt,
  showstringspaces=false,
  numbers=left,
  stepnumber=1,
  numberstyle=\sffamily\tiny,
  tabsize=2
}

\begin{document}
\maketitle

\section{課題2-1}

\subsection{課題内容}

echoserverプログラムと通信するクライアントプログラムを作成せよ。

\subsection{仕様}

このプログラムの仕様と、引数の与え方を以下に示す。

\begin{screen}
  {\bf echoclient} hostname
\end{screen}

\begin{itemize}
\item 引数として与えられたhost上で動作しているechoserverプログラムと、
  ポート番号10120を介して接続する。引数がない場合や、
  hostが見つからない場合、host上でサーバーが動作していないときはエラーを返す。
\item 標準入力から読み込んだ文字列をechoserverプログラムへ送信し、
  受信した文字列を標準出力に書き出す。この動作を繰り返す。
\item 標準入力からEOFを受け取ると、サーバーとの接続を切断し、プログラムを終了する。
\end{itemize}

\subsection{ソースコード}

\lstinputlisting[caption=echoclient.c,label=cli]
{echoclient.c}

\subsection{実装方法}
\ref{si}
\paragraph{引数の確認}
まずは、引数が正しく与えられているかを確認する。
引数が与えられていないときは、正しい使い方を出力して、
プログラムを終了する。

\paragraph{ソケットの生成}
socket()システムコールを用いてソケットを作成する。
第1引数はドメインの種類を指定する。
ここではINETドメインを用いるため\verb+AF_INET+を指定する。
第2引数にはソケットの方を指定する。
TCPはストリーム型の通信であるため、
\verb+SOCK_STREAM+を指定する。
第3引数にはプロトコルの種類を指定する。
今回はTCPプロトコルを用いるため、
\verb+IPPROTO_TCP+を指定する。

\paragraph{hostの情報設定}
bzero()ライブラリコールを用いて\verb+sockaddr_in+構造体を初期化する。
INETドメインでは、\verb+sin_family+に\verb+AF_INET+を指定する。
すべてのネットワークインターフェースからパケットを受信できるように、
\verb+sin_addr+に\verb+INADDR_ANY+を指定する。
\verb+sin_port+に、使用するポート番号10120を指定する。

\paragraph{IPアドレスの取得}
gethostbyname()ライブラリコールをを用いて、
引数のホスト名からIPアドレスを取得し、
\verb+sin_addr+にbcopy()を用いて代入する。
IPアドレスが取得できなかった場合は、
エラーメッセージを出力して、プログラムを終了する。

\paragraph{サーバーに接続}
connect()システムコールを用いて、サーバーとの接続を確立する。
第1引数にソケット、第2引数に接続先のソケットアドレス、
第3引数にソケットアドレスの大きさを与える。
接続に失敗した場合はプログラムを終了する。

\paragraph{メッセージ送受信}
サーバーとの接続が確立できたら、
メッセージの送受信を行う。
read()システムコールの第1引数に0を指定して、
標準入力から入力を受け付ける。
正しく入力できたら、
write()システムコールの第1引数にsockを指定して、
入力した文字列をサーバーに送信する。

EOF以外の文字列を入力した際は、
サーバーから同じ文字列が返ってくるので、
read()の第1引数にsockを指定して受け取り、
write()の第1引数に1を指定して、標準出力に出力する。

この動作をEOFが入力されるまで繰り返す。
EOFが入力されたら、close()でサーバーとの接続を切断し、
プログラムを終了する。

\subsection{実行結果}

演習室の端末上で実行した結果を以下に示す。
exp192上でechoclient.exeを、exp134上でechoclient.exeを実行した。

\begin{verbatim}
exp192% ./echoclient.exe                                               [~/En-C]
Usage: ./echoclient.exe hostname
exp192% ./echoclient.exe hogehoge                                      [~/En-C]
unknown host hogehoge
exp192% ./echoclient.exe exp134                                        [~/En-C]
abdcf
abdcf
QWERTY
QWERTY
あいうえお
あいうえお
closed

-------------------------------------------------------------------------------

exp134% ./echoserver.exe                                               [~/En-C]
[exp192.exp.ics.es.osaka-u.ac.jp]
closed


\end{verbatim}

引数を与えずに実行すると、
正しい使用方法を示すエラーメッセージが表示される。
存在しないクライアント名を指定した場合、
エラーメッセージが表示される。

echoclient.exeを実行しているexp134に接続すると、
exp134上に接続を受け付けたことが表示される。
この状態でexp192に文字を入力すると、
同じ文字列が返ってくる。
EOFを送信すると、
両方の端末にclosedと表示され、
正しく接続を切断できたことがわかる。

\section{課題2-2}
\label{22}
\subsection{課題内容}

簡易talkを実現する、
simple-talk-serverプログラムを完成させよ。
また、サーバー側と同様に、
クライアントが側のプログラム、
simple-talk-client作成せよ。

\subsection{仕様}

このプログラムの仕様と、引数の与え方を以下に示す。

\begin{screen}
  {\bf simple-talk-server}
\end{screen}

\begin{screen}
  {\bf simple-talk-client} hostname
\end{screen}

\begin{itemize}
\item simple-talk-serverを起動してから、
  simple-talk-serverが動作しているホスト名を指定して、
  simple-talk-client を起動することで接続が確立する。
\item 接続確立後は、simple-talk-server 側で標準入力から入力した文字列が即座に
  simple-talk-client 側に表示される。逆も同様。
\item 全二重通信で実現され、会話をする二人がどのような順序で発言を行なっても、
  相手側に即座にそのメッセージが表示される。
\item EOFを入力すると、接続が切断され、
  simple-talk-clientは実行を終了する。
  simple-talk-serverは引き続き接続を待ち受ける。
\end{itemize}

また、発展課題として、以下の仕様を追加した。

\begin{itemize}
\item 相手からのメッセージを受信した際、
相手の端末名をメッセージの先頭に表示する。
\end{itemize}

\subsection{ソースコード}

\lstinputlisting[caption=simple-talk-server.c,label=sts]
{simple-talk-server.c}

\lstinputlisting[caption=simple-talk-client.c,label=stc]
{simple-talk-client.c}


\subsection{実装方法}

まず、simple-talk-serverの実装方法を説明する。
課題2-1で作成したプログラムと同じ内容も多数含まれているため、
その部分は説明を省略した。

\subsubsection{simple-talk-server}

\paragraph{ソケットの生成}
最初に、クライアントを受け付けるためのソケットを生成する。
作成するソケットは、課題2-1と同じである。

\paragraph{ソケットアドレス再利用の指定}
サーバーが異常終了した時に、
すぐ再起動できるようにするおまじないである。
詳しい説明は省略する。

\paragraph{client受付用ソケットの情報設定}
先ほど作成したソケットの情報を設定する。
設定内容は課題2-1と同様である。
使用するポート番号に10130を指定する。

\paragraph{ソケットにソケットアドレスを割り当てる}
この部分も課題2-1と同様である。

\paragraph{待ち受けクライアント数の設定}
listen()システムコールを用いて、
接続要求を受け入れる用意があること、
次のaccept()処理中に到着した接続要求をいくつまで待たせることができるか、
を設定する。
今回は1対1のチャットプログラムであるため、
1を指定している。

\paragraph{クライアントの受付}
accept()システムコールを用いて、
クライアントからのconnect()による接続要求を受け入れる。
受け入れが完了したら、クライアントと接続するためのソケットを新たに生成し、
同時にクライアントのソケットアドレスを取得してcltに格納する。

\paragraph{クライアントのホスト情報の取得}
課題2-1と同様にして、クライアントのホスト名を取得する。
取得が完了したら、
ホスト名を標準出力に表示する。

\paragraph{入力を監視するファイル記述子の集合を変数 rfds にセットする}
rfdsを空集合に初期化した後、
入力を監視するファイル記述子として、
標準入力と、クライアントを受け付けたソケットを追加する。
その後、監視する待ち時間を1.0秒に指定する。

\paragraph{標準入力とソケットからの受信を同時に監視する}
select()システムコールを用いて、標準入力とソケットからの受信を同時に監視する。
第1引数には、監視するファイル記述子の最大値に1加えた値を指定する。
第2引数には、読み込みを監視するファイル記述子の集合、すなわちrfdsを指定する。
第3,4引数には、何も指定しないのでNULLを入力する。
第5引数には、先ほど設定した、監視する待ち時間を指定する。

select() が終了すると、
状態が変化したファイル記述子の集合を、
第 2引数で指定されたrfdsに格納し、
返り値として、状態が変化したファイル記述子の数を返す。
そのためこの行では、返り値が0より大きかった場合にif文の中が実行されるようになっている。

\paragraph{標準入力から入力があった場合の処理}
FD\verb+_+ISSET()で、rfdsに0が存在するかを調べる。
0が存在する場合は、標準入力からの入力があったことになるので、
read()で標準入力から読み込み、
write()で標準出力とソケットに出力する。
このとき、標準入力には、
自分が入力したことを示すために、
``server ''という文字列を表示する。
read()とwrite()を用いた通信の手順については課題2-1と同様である。

\paragraph{ソケットから受信した場合の処理}
FD\verb+_+ISSET()を実行してrfdsにcsockが存在した場合は、
ソケットからデータを受信したことになる。
read()でソケットから読み込み、
write()で標準出力に出力する。
この時、文字列の先頭に相手のホスト名を表示する。
``cp->h\verb+_+name''にホスト名が格納されているので、
これをwrite()で出力すればよい。

\paragraph{EOFが入力・受信されるまで繰り返す}
ここまでの監視・処理分岐の流れを、
EOFが入力・受信されるまで繰り返す。
EOFを受け取ったら接続を切断し、
クライアントの待受け処理に戻る。

\subsubsection{simple-talk-client}
次に、simple-talk-clientの実装について説明する。
ただし、ソケットを作成してからクライアントに接続するまでの処理は、
課題2-1と全く同一であり、
select()を利用してデータをやり取りする部分は、
simple-talk-serverとほとんど同一である。
そのため、プログラムの詳しい説明は省略し、
主に全体の流れを説明する。

\paragraph{ソケットの生成--ホストに接続}
ソケットを生成してからホストに接続するまでの処理内容は、
echoclientと同じである。
ホストの情報設定をする際に、ポート番号として10130を指定している。

ホストとの接続が完了した場合は、そのメッセージを表示する。

\paragraph{標準入力とソケットからの受信を同時に監視する}
select()で標準入力とソケットからの受信を同時に受け付ける処理は、
simple-talk-serverと同様である。
標準入力から読み込んだ時には、
``client ''という文字列を自分の端末に表示する。
ソケットから読み込んだ際には、``hp->h\verb+_+name''に保管されている
ホスト名を、データの先頭に出力する。

これらの処理をEOFが入力・受信されるまで繰り返す。

\paragraph{接続を切断する}
EOFが入力されたら、ホストとの接続を切断し、プログラムを終了する。


\subsection{実行結果}

演習室の端末上で実行した結果を以下に示す。
exp134上でsimple-talk-server.exeを実行し、
exp192上でsimple-talk-client.exeを実行した。

\begin{verbatim}
exp192% ./simple-talk-client.exe exp134                                [~/En-C]
Connected to [exp134.exp.ics.es.osaka-u.ac.jp]
Hello!
client Hello!
exp134.exp.ics.es.osaka-u.ac.jp asdfg
あいうえお
client あいうえお
QWERT
client QWERT
client closed

------------------------------------------------------------------------------

exp134% ./simple-talk-server.exe                                       [~/En-C]
Conneced to [exp192.exp.ics.es.osaka-u.ac.jp]
exp192.exp.ics.es.osaka-u.ac.jp Hello!
asdfg
server asdfg
exp192.exp.ics.es.osaka-u.ac.jp あいうえお
exp192.exp.ics.es.osaka-u.ac.jp QWERT
exp192.exp.ics.es.osaka-u.ac.jp closed

\end{verbatim}
「./simple-talk-client.exe exp134」を実行して、
ザーバーとの接続に成功すると、
接続相手の名前が両方の端末上に表示される。

exp192上で文字列を打ち込むと、
両方の端末で文字列が名前付きで表示される。
その逆も同様である。

exp192が連続して文字を送信した場合も、正しく送信できている。
最後にEOFを送信すると、正しく接続が切断された。

このことから、2つのプログラムは仕様を満たしている。


\section{発展課題}

\subsection{課題内容}
今回は以下の発展課題に挑戦した。

\begin{description}
 \item[1]echoserverを改造して、
   受信した文字列中のすべての大文字を小文字に変換して返すサーバ
   lowerechoserver を作成せよ。
 \item[3]simple-talk-server、simple-talk-client プログラムに手を加えて、
   サーバ側、クライアント側 の各行に誰の発言であるか表示する機能を追加せよ。
 \item[5]udp sender をブロードキャストが利用できるように改造し、動作を確かめてみよ。
 \item[7]UDPを用いた代表的なサービスを列挙し、TCPに比べてUDPを用いる利点・欠点を考察せよ。
   簡易 talk は UDP を用いるのにふさわしいアプリケーションといえるか?
 \item[8]課題 2-1 で作成したプログラムを一部改造することで、
   World Wide Web から情報を取得する簡易 HTTP クライアントを作成せよ。
\end{description}

\subsection{発展課題1}

\subsubsection{仕様}
lowerechoserverは、受信したすべての大文字を小文字に変換して
返すサーバーである。大文字以外の文字はそのまま返す。
それ以外の仕様は、echoserverと同じである。

\subsubsection{ソースコード}

echoserver.cからの省略部分のみを示す。

\begin{lstlisting}[caption=lowerechoserver.c(一部),label=lo]

/*   省略   */

/* 文字列中の英大文字を小文字に変換 */
char *StrToLower(char *s) {

    char *cp;

    for (cp = s; *cp; cp++) {
        *cp = tolower(*cp);
    }
    return (s);
}

int main(int argc,char **argv) {

char *lbuf;

/*   省略   */

    do {
        /* クライアントからのメッセージ受信 */
        if ( ( nbytes = read(csock,rbuf,sizeof(rbuf)) ) < 0) {
            perror("read");
        } else {

            /* 受信文字列を小文字に変換してクライアントへ返す (echo) */
            lbuf = StrToLower(rbuf);
            write(csock,lbuf,strlen(lbuf));
            /* ↑ 改造部分 ↑ */
      }

    } while ( nbytes != 0 );
    /* read() が 0 を返すまで (=End-Of-File) 繰り返す */

/*   省略   */

\end{lstlisting}

\subsubsection{実装方法}
まず、英大文字を小文字に変換する関数StrToLower()を作成した。
この関数は、string.hで定義されているtolower()を用いて、
文字列を一文字ずつ小文字に変換する。

次に、write()でクライアントにメッセージを返す部分に改造を加える。
受信したメッセージはrbufに格納されているので、これに対してStrToLower()を適用し、
変換した文字列をwrite()でクライアントに送信する。

\subsubsection{実行結果}

演習室の端末上で実行した結果を以下に示す。
exp134でlowerechoserver.exeを実行しておき、
exp192でechoclient.exeを実行してメッセージを送った。

\begin{verbatim}
exp192% ./echoclient.exe exp134                                        [~/En-C]
ASDFG
asdfg
QwErT
qwert
closed

exp134% ./lowerechoserver.exe                                          [~/En-C]
[exp192.exp.ics.es.osaka-u.ac.jp]
closed
\end{verbatim}

大文字がすべて小文字に変換されているので、
プログラムは正しく実装できていることがわかる。

\subsection{発展課題3}

この発展課題の実装、実行結果などについては、\ref{22}にすでに記述してある。

\subsection{発展課題5}

\subsubsection{仕様}
udp\vreb+_+send.cを一部改造し、
「192.168.16.255」にメッセージを送信すると、
udp\verb+_+reseive.exeを実行しているすべての端末でメッセージを受信できるようにする。

\subsubsection{実装方法}
ブロードキャストを行うためには、
ソケットを生成した後に、以下の設定を加えれば良い。

\begin{verbatim}
int yes = 1;

/* ブロードキャストのための設定 */
  setsockopt(sock,
             SOL_SOCKET, SO_BROADCAST, (char *)&yes, sizeof(yes));
\end{verbatim}

この設定を行うと、ソケットに「\verb+SO_BROADCAST+」が設定され、
ブロードキャストを行うことができるようになる。

\subsubsection{実行結果}

演習室の端末上で実行した結果を以下に示す。
exp134でudp\verb+_+reseive.exeを実行し、
exp192でudp\verb+_+send.exeを実行し、
192.168.16.255に対してHELLOという文字列を送ると、
exp134でメッセージが受信されている。

メッセージが2回受信されているのは、
演習室のネットワーク設定によるものなので、プログラムの問題ではない。

\begin{verbatim}
exp192% ./udp_send.exe 192.168.16.255 HELLO                        [~/En-C/udp]


exp134% ./udp_receive.exe                                          [~/En-C/udp]
HELLO from [192.168.16.192:16619]
HELLO from [192.168.16.192:16619]
^C
\end{verbatim}

\subsection{発展課題7}
UDPを用いた代表的なアプリケーションには、
ブロードキャスト機能を用いたWindowsネットワークや、
リアルタイム通信を行うストリーミング放送等がある。

UDPの利点は、ブロードキャストを行うことができるということである。
TCPは通信相手との間に必ずコネクションを確立して通信するため、
ブロードキャストを行うことができない。
従って、ブロードキャストを用いるアプリケーションでは、
必ずUDPを使うことになる。

また、リアルタイム通信に適しているのも、UDPの利点である。
リアルタイム通信では、常に決まった量のパケットを起こり続ける必要があるが、
このような処理にTCPは向いていない。
TCPは、勝手に送出速度が調整されたり、
後から届いても意味が無いのにパケットを再送したりしてしまうからである。
それに対してUDPは、問題なくパケットを送信し続けることができるので都合がよい。

これらのメリットと引き換えに、
UDPでは通信の信頼性を確保する仕組みや、
順番が前後して届いたパケットの順番を直す仕組みが存在しない。
このような仕組みをアプリケーション側で準備しなくてはならないことは、
UDPを用いる上でのデメリットである。

今回作成した簡易talkは、通信相手との接続を確立した後、
断続的にパケットを送信するものである。
送信したパケットは確実に相手に届けられる必要がある。
このことを考慮すると、
このプログラムには、UDPを用いるのは適していないと考えられる。
UDPは接続の確立や、パケットの確実な送信のために、
プログラム側でこれらの仕組みを用意する必要があるが、
TCPでは予め用意されているため、実装が簡単になるからである。

参考文献「図解で学ぶネットワークの基礎：UDP編 - Lesson4：一斉同報やストリーミングはUDPならではの通信方法：ITpro」(http://itpro.nikkeibp.co.jp/article/COLUMN/20070713/277538/) 2013/5/29アクセス

\subsection{発展課題8}

\subsubsection{仕様}

課題2-1で作成したechoClient.cを一部改造して、
HTTPサーバーからデータをダウンロードするHTTPClient.cを作成した。
このプログラムは、ソースコード中で予め指定されたアドレスにアクセスし、
データをダウンロードして端末に表示する。
アクセスするアドレスは「http://www.ietf.org/rfc/rfc1866.txt」(HTTP2.0の仕様書)である。

\subsubsection{ソースコード}

\lstinputlisting[caption=HTTPClient.c,label=thl]
{HTTPClient.c}

\end{document}