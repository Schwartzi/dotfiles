\documentclass{jsarticle}
\title{情報科学演習C 第2回レポート課題} % 題目
\author{谷村亮介}                    % 提出者名
\date{平成25年7月4日(木)}            % 提出日

% \課題名{ネットワークプログラミングの基礎}   % 課題名
% \担当教官{内山彰}                       % 担当教官名
% \所属{ソフトウェア科学コース}             % 自分の所属するコース名などを指定する.
% \学年{3年}                             % 学年
% \学籍番号{09B11044}                    % 学籍番号
% \email{u549298j@ecs.osaka-u.ac.jp}    % 電子メールのアドレス

\usepackage{ascmac}
\usepackage{here}
\usepackage{txfonts}
\usepackage{listings, jlisting}
\usepackage{color}
\usepackage[dvips]{graphicx}


\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{colFunc}{rgb}{1,0.07,0.54}
\definecolor{CadetBlue}{cmyk}{0.62,0.57,0.23,0}
\definecolor{Brown}{cmyk}{0,0.81,1,0.60}
\definecolor{colID}{rgb}{0.63,0.44,0}


\renewcommand{\lstlistingname}{リスト}
\lstset{language=c,
  backgroundcolor={\color[gray]{.95}},%
  basicstyle=\sffamily\scriptsize,
  keywordstyle={\bfseries \color{OliveGreen}},
  commentstyle={\itshape \color{Brown}},
  stringstyle={\ttfamily \color{CadetBlue}},
  frame=tRBl,
  framesep=5pt,
  showstringspaces=false,
  numbers=left,
  stepnumber=1,
  numberstyle=\sffamily\tiny,
  tabsize=2
}

\begin{document}
\tableofcontents
\newpage
\section{課題3-1}

\subsection{課題内容}

セマフォを用いて排他制御を実現し、
指導書2.2.1節のfile-counterプログラムが確実に正しく動作するようにせよ。
正しい動作とは、
「1. counter ファイルの内容が最終的に 4 になること」
「2. 何度実行しても同じ結果になること」
「3. file-counter プログラムが単体で動作すること」
の条件を満たすことである。

\subsection{仕様}

filecounterプログラムの仕様を以下に示す。

\begin{itemize}
\item このプログラムは、引数を与えずに実行する。
\item 実行するためには、同一ディレクトリ内に、「semaphore」という名前のファイルが必要である。
\item プログラムと同じディレクトリに「counter」というテキストファイルを生成し、「0」を書き込む。
\item 4つのプロセスを生成し、排他制御を行いながら、
  それぞれのプロセスがcounterの値を1加算して書き換える。
\item すべての処理が終了した結果、counterの値は必ず「4」となる。
\item 以下のエラーが起こった場合は、メッセージを出力してプログラムを強制終了する。
  \begin{itemize}
  \item セマフォが作成できなかった時
  \item counterというファイルの読み込みや書き込みができなかった時
  \item プロセスが生成できなかった時
  \item セマフォが操作できなかった時
  \item セマフォを削除できなかった時
  \end{itemize}
\end{itemize}

\subsection{ソースコード}

\lstinputlisting[caption=filecounter.c,label=cou]
{filecounter.c}

\subsection{実装方法}
\label{semop}
このプログラムの実装方法を以下に示す。
なお、各段落の見出しは、ソースコード中の同じ文に該当する。
これ以降の「実装方法」の章でも同じ記述方法を採用している。

count1()関数については、指導書の関数と変更がないので、
説明は省略する。

\paragraph{セマフォ操作関数}
waitやsignalなどのセマフォ操作は、
関数としてまとめておくとソースコードが見やすくなる。
このために、セマフォ操作関数mySemop()を作成した。

この関数は、第1引数から順に、セマフォID、セマフォ番号、セマフォ操作を指定する。
セマフォ操作を-1に指定すると、セマフォIDとセマフォ番号で指定されたセマフォに対して、
wait操作を実行する。
セマフォ操作を1に指定すると、signal操作となる。
semop()に失敗した場合は、メッセージを出力して強制終了する。

\paragraph{セマフォの作成}
プログラムを実行したら、
最初にセマフォを作成する。
この処理は指示書と同じ手順である。
セマフォが作成できなければプログラムを強制終了する。
その後、semctl()関数で、セマフォの値を1にしておく。

\paragraph{counterに0を書き込む}
fopen()でcounterというファイルをオープンする。
counterが存在しないときは新たに作成する。
ファイルのオープン時にエラーが発生すれば、
プログラムを強制終了する。
fprintf()でcounterに0を書き込み、
ファイルをクローズする。

\paragraph{プロセスの生成と実行}
fork()関数をfor文で繰り返し実行してプロセスを4つ生成する。
プロセスの生成に失敗したら、プログラムを強制終了する。

\paragraph{子プロセスの処理}
ここからは子プロセスと親プロセスの処理に分岐する。
4つの子プロセスは、それぞれcount1()関数を1回実行して終了する。
この関数がクリティカルセクションに該当するので、
この関数を実行する前後でwaitとsignalを実行する。

まず、mySemop()の第3引数に-1を指定し、
wait操作を行う。
最初はセマフォの値が1になっているので、
次の操作が実行できる。
他のプロセスがcount1()を実行している時には、
セマフォは0になっているため、
ここで待機する。

count1()が終了したら、
mySemop()の第3引数に1を指定して、
signal操作を実行する。
wait操作で待機しているプロセスがあれば、
そのプロセスが実行される。

最後に、現在のcounterの値を出力してプロセスを終了する。

\paragraph{親プロセスの処理}
親プロセスは、wait()関数で、
全ての子プロセスが終了するのを待機する。

\paragraph{セマフォを削除}
semctl()の第3引数に\verb+IPC_RMID+を指定して、作成したセマフォを削除し、
プログラムの実行を終了する。

\subsection{実行結果}
filecounter.exeの実行結果を以下に示す。
このプログラムは何回も実行したが、
紙面の都合上、2回分の実行結果を示す。

\begin{screen}
\begin{verbatim}
% ./filecounter.exe
count = 1
count = 2
count = 3
count = 4
% cat counter
4
% ./filecounter.exe
count = 1
count = 2
count = 3
count = 4
% cat counter
4
\end{verbatim}
\end{screen}


プログラムを何回実行しても、
counterの中身は最終的に4になっている。
従って、このプログラムは仕様を満たしている。

なお、セマフォの生成に失敗した際などの、
エラーメッセージの出力に関しては、
再現が難しいため、正しく実装できているかは実際に確認していない。

\subsection{考察}
このプログラムにとりかかる時、
セマフォの仕組み自体を理解するのは容易であったが、
C言語での実装は、やや癖があり、正しく実装することが難しかった。
これに対しては、
セマフォを操作するための関数を自分で用意したことで、
より簡単に操作をすることが可能になった。
自分が操作したい内容に応じて関数をカスタマイズすることで、
より使いやすいセマフォ操作を実現することが出来た。
今後、このような新たな機能を利用するときには、
積極的に関数化し、自分にとって扱いやすいものにしていくことが重要だと考えられる。

今回セマフォを使用していて疑問に思ったことは、
セマフォのインクリメントやデクリメントもクリティカルセクションに該当するのではないのか、
ということである。
これについて詳しく調べてみると、
セマフォのインクリメントなどには、
「デッカーのアルゴリズム」などの排他制御アルゴリズムが用いられているようであった。
このように、適切な排他制御が行われているため、
セマフォを使えばシンプルなWAIT、SIGNAL命令だけで排他制御を行うことができるのである。
今後、プロセス間で排他制御を行う際には、
セマフォを積極的に利用して行きたいと思った。

\newpage
\section{課題3-2-1}

\subsection{課題内容}
指導書4.1章のpipe.c を拡張し、双方向パイプのプログラム two-way-pipe を作成せよ。

\subsection{仕様}
このプログラムの引数の与え方と、
仕様を以下に示す。

\begin{screen}
  {\bf two-way-pipe} MessageToParent MessageToChild
\end{screen}

\begin{itemize}
\item このプログラムは2つの引数をとる、引数の数が足りないときは、エラーを出力する。
\item 子プロセスと2つのパイプを生成する。
\item パイプを利用して、第1引数の文字列を子プロセスから親プロセスへ渡し、
  同時に、第2引数の文字列を親プロセスから子プロセスに渡す。
\item 各プロセスは、送られてきた文字列を同時に出力する。
\end{itemize}

\subsection{ソースコード}
\lstinputlisting[caption=two-way-pipe.c,label=two]
{two-way-pipe.c}

\subsection{実装方法}

\paragraph{引数の確認}
引数の数が正しいか確認する。
引数が2つでないときにはエラーを出力してプログラムを終了する。

\paragraph{パイプと子プロセスの生成}
pipe()関数で2つのパイプを生成する。
親から子へのパイプを「fd\verb+_+PtoC」、
子から親へのパイプを「fd\verb+_+CtoP」と名付ける。

fork()関数で、子プロセスを1つ生成する。

\paragraph{子プロセスの処理}
まず、close()関数で、
親から子へのパイプに書き込みすることと、
子から親へのパイプから読み出しすることを禁止する。

次に、write()関数で、第1引数の文字列を子から親へのパイプに書き込む。
そして、read()関数で、親から子へのパイプに書き込まれた内容を読み出し、
printf()関数で、標準出力に出力する。

これで、子プロセスの処理は終了である。

\paragraph{親プロセスの処理}
親プロセスの処理の流れは、
子プロセスのものと同じである。
closeするパイプと、
書き込み、読み出しするパイプを、
子プロセスの場合と逆にすれば良い。

メッセージを出力したら、
wait()関数で子プロセスの終了を待機し、
プログラムを終了する。

\subsection{実行結果}
two-way-pipe.exeを数回実行した結果を以下に示す。

\begin{screen}
\begin{verbatim}
% ./two-way-pipe.exe FROMCHILD FROMPARENT
Message from Parent process:    FROMPARENT
Message from child process:     FROMCHILD
$ ./two-way-pipe.exe FROMCHILD FROMPARENT
Message from child process:     FROMCHILD
Message from Parent process:    FROMPARENT
\end{verbatim}
\end{screen}


このプログラムを実行した結果、
親子間で正しくメッセージをやりとりできている。
また、何回か実行すると、親の処理が先に実行されていたり、
子の処理が先に実行されていたりすることから、
親プロセスと子プロセスの処理は同時に実行されていることがわかる。

従って、このプログラムは仕様を満たしている。

\subsection{考察}

このプログラムの作成は、
極めて簡単であった。
パイプによるプロセス間通信で注意しなければならないことは、
同じプロセスが1つのパイプに対して読み込みと書き込みの両方をおこなってはならない、ということである。
そのため、プロセス間で双方向に通信したい際には、
今回のようにパイプを2つ用意しておく必要がある。

このことを守っておけば、
あとはファイルに読み書きするのと同じようにすれば、
プロセス間通信を行うことができるため、
パイプは大変有効な手段であるといえる。
パイプを有効活用すれば、
マルチプロセスプログラミングの幅をより広げることができるであろう。


\section{課題3-2-2}

\subsection{課題内容}
CLE の課題 3 に添付したマージソートを行うプログラム mergesort.c を拡張し、
並列版 マージソートを作成せよ。

さらに,配列のサイズ N(\verb+NUM_ITEMS+)を増やした場合の動作を確認せよ。
N が大きくなっても正常に動作するよう、プログラムを改良せよ。

\subsection{仕様}

今回は、mergesort.c内の関数mergeSort()のみを改造して、
並列版マージソートmergesortPipe.cを作成した。
ここでは、改造したmergeSort()関数の仕様のみを記す。

\begin{itemize}
\item 最初に、プロセス間通信用のパイプを生成し、子プロセスを生成する。
\item 子プロセスは配列の前半分を、親プロセスは配列の後半分をマージソートする。
\item パイプを利用して、子プロセスでソートした配列を親プロセスへ渡す。
\item 親プロセスは、2つの部分配列をマージし、結果を得る。
\end{itemize}

\subsection{ソースコード}
\lstinputlisting[caption=mergesortPipe.c,label=mg]
{mergesortPipe.c}

\subsection{実装方法}
mergeSort()の実装方法のみ解説する。

\paragraph{パイプと子プロセスの生成}
pipe()関数でパイプを生成する。
また、fork()関数で、子プロセスを1つ生成する。

\paragraph{子プロセスの処理}
まず、close()関数で、
パイプから読み出しすることを禁止する。

次に、\verb+m_sort(numbers, temp, 0, mid)+を実行することで、
配列の前半分をマージソートする。
ソートが完了したら、write()関数で、ソートした配列の要素を1つずつパイプに書き込む。

これで、子プロセスの処理は終了である。

\paragraph{親プロセスの処理}
まず、close()関数で、
パイプに書き込むことを禁止する。

子プロセスの場合と同様にして、
配列の後半分をマージソートする。

ソートが完了したら、
子プロセスがソートした配列の要素を1つずつパイプから読み取り、
配列の前半分にコピーしていく。

その後、配列をマージすれば、結果を得ることができる。
wait()関数で子プロセスの終了を見届けると、
関数の処理が完了する。


例として、配列が10個の場合の、具体的な処理の流れを以下に示した。

\begin{screen}
\begin{verbatim}
3 5 7 4 9 1 8 2 0 6
  ↓プロセス生成
親プロセス             子プロセス
3 5 7 4 9 1 8 2 0 6   3 5 7 4 9 1 8 2 0 6
  ↓マージソート(後)       ↓マージソート(前)
3 5 7 4 9|0 1 2 6 8   3 4 5 7 9|1 8 2 0 6
  ↓パイプで送受信
3 4 5 7 9|0 1 2 6 8
  ↓マージ
0 1 2 3 4 5 6 7 8 9
\end{verbatim}
\end{screen}


\subsection{実行結果}
mergesortPipe.exeを実行した結果の一部を以下に示す。

\begin{screen}
\begin{verbatim}
% ./mergesortPipe.exe
Done with sort.
1844796
2633903
2977667
4850017
7204030
8818600
13410583
22074909
22479562
26886988
---(略)---
\end{verbatim}
\end{screen}


紙面の都合上、
出力結果の一部のみを掲載しているが、
配列の数を100000個にしても、
プログラムは停止せずに結果を出力することが出来た。

また、出力結果をsortコマンドなどでソートし、
diffコマンドでそれと出力結果とを比較したところ、
差異は見られなかったことから、
ソートは正しく行うことができていると分かる。

従って、このプログラムは仕様を満たしている。

\subsection{考察}
今回の課題では、
ソートのプログラムは予め与えられていたため、
関数の役割さえ理解すれば、
実装の方針を立てるのは容易であった。
この課題で苦労したことは、
配列のサイズが大きい時に、
配列を分割してパイプに書き込む必要がある、ということである。
ここでは配列の要素を1つずつパイプに書き込むことで、
この問題を回避した。
要求された仕様は満たしているものの、
これでは実行効率があまり良くない。
配列を一定のサイズで分割し、
ブロックごとにやり取りすれば、
より実行効率が上がるかもしれない。
今回は、処理を高速化することは要求されていなかったため、
実行速度については評価しなかったが、
実行速度が求められている場合には、
この部分の処理を見直す必要があるだろう。

\newpage

\section{課題3-3-1}

\subsection{課題内容}
alarm() を使用せずに、同等の機能を実現する myalarm() をマルチプロセスを用いて実装せよ。
alarm.c の関数 myalarm() の定義を書き換えて、alarm() を使わずに同等の機能を実現する。
その際、以下の条件を満たす必要がある。

\begin{enumerate}
\item 書き換えて良いのはmyalarm()の中だけである。
\item 呼び出し元のプロセスの処理は、myalarm()を呼び出したらすぐに戻ってくること。
\item マルチプロセスを利用して、指定した秒数が経過したら呼び出し元のプロセスに \verb+SIGALRM+ を送信する。
  その際、子プロセスがゾンビプロセスとなって残らないように注意する。
\item すでにタイマーがセットされていた場合、そのタイマーを削除して新しいタイマーを設定する
  (myalarm() を呼び出すたびにプロセスが増えていってはならない)。
\end{enumerate}

\subsection{仕様}
今回は、myalarm()関数のみの仕様を示す。

\begin{itemize}
\item 最初に、タイマー機能を実現するための子プロセスを生成する。
\item 子プロセスは、関数の引数で指定された秒数だけ待機したあと、
  親プロセスが存在する場合には、\verb+SIGALRM+を送信する。その後プロセスを終了する。
  親プロセスが何らかの原因で存在しない場合には、何もせずに終了する。
\item 親プロセスは、既存の子プロセスを削除し、新たに生成した子プロセスのPIDを保存する。
  その後、子プロセスの終了を無視する処理を施し、関数を終了する。
\end{itemize}

\subsection{ソースコード}
\lstinputlisting[caption=myAlarm.c,label=my]
{myAlarm.c}

\subsection{実装方法}

\paragraph{子プロセスの生成}
始めに、folk()関数を用いて子プロセスを生成する。
この子プロセスが、タイマー機能を実現する。

\paragraph{子プロセスの処理}
生成された子プロセスは、
myAlarm()関数の引数で指定された秒数だけ待機する。
その後、親プロセスが存在するか確認する。
kill(getppid(), 0)の返り値が0の時、
親プロセスが存在していることがわかる。
返り値がそれ以外だった場合は、
強制終了などによって親プロセスが存在していないので、
何もせずに子プロセスを終了する。

親プロセスが存在していた場合は、
親プロセスにSIGALARMを送信し、
子プロセスを終了する。

\paragraph{親プロセスの処理}

\subparagraph{既存の子プロセスを削除}

myAlarm()関数が2回目以降に呼び出された場合は、
前回生成された子プロセスを削除しなければならない。
前の子プロセスのPIDは、oldPidという変数に保存されている。
この変数は、static修飾子をつけて宣言されているため、
関数が終了した後も、値が残り続ける。
前の子プロセスが存在するとき、
すなわちoldPidの値が0でないときには、
そのPIDに対してSIGTERMを送信することで、子プロセスを削除する。

\subparagraph{作成した子プロセスのPIDを保存}
今回作成した子プロセスのPIDを、
oldPidに保存しておく。
これにより、次にmyAlarm()を呼び出した時に、
前の子プロセスのPIDを知ることができる。

\subparagraph{子プロセスの終了を無視}
signal(SIGCHLD, SIG\_IGN)を実行することで、
SIGCHLDというシグナルを無視することができる。
SIGCHLDは、子プロセスの終了を親プロセスに通知するシグナルであり、
これを無視する設定にすることで、子プロセスの終了を監視しなくても、
ゾンビプロセスになるのを防ぐことができる。

この処理を実行した後は、関数を終了する。


\subsection{実行結果}
myAlarm.exeを実行した結果を以下に示す。
タイムアウトまでの時間は10秒に設定した。
timeコマンドを使用し、実行にかかった時間を示した。

\begin{screen}
\begin{verbatim}
% time ./myAlarm.exe
a
echo: a
s
echo: s
d
echo: d
This program is timeout.
./myAalarm.exe  0.00s user 0.00s system 0% cpu 13.096 total
% time ./myAlarm.exe
a
echo: a
s
echo: s
^C
./myAalarm.exe  0.00s user 0.00s system 0% cpu 3.119 total
% ps
  PID TTY           TIME CMD
 6555 ttys000    0:04.55 -zsh
\end{verbatim}
\end{screen}


このプログラムを実行した結果、
最後に文字を入力してから10秒後にタイムアウトが発生した。
このことから、前に設定したアラームは正しく削除できていることがわかる。

また、プログラムを途中で強制終了した場合は、
その後に子プロセスからSIGALRMが送信されていない。

psコマンドを実行した結果、
ゾンビプロセスは存在しなかった。

従って、このプログラムは仕様を満たしている。

\subsection{考察}

このプログラムの作成にあたって困難だったことは、
子プロセスのプロセスIDを、
関数が終了した後も保持しておくことであった。
今回は、static修飾子をつけた変数を使用することで、
この問題を解決した。
関数の中で大域変数を作ってしまうのは、
あまり良い方法ではないが、
今回の課題内容を満たすためにはこの方法が適切であると考えられる。

プログラムを完成させた後、
要求された仕様を満たしただけでは、
「タイマーをセットした状態で親プロセスが強制終了などで消滅してしまうと、
子プロセスはシグナルの送信に失敗して、エラーを出力してしまう」
という問題が発生することに気づいた。
この問題は、
親プロセスが存在するか確認してから、
親プロセスにシグナルを送ることで解決することが出来た。
このように、複数プロセスを使用するプログラムでは、
単一プロセスのプログラムでは考えられないようなバグが発生してしまうことがある。
今回のようなプログラムをデバッグする際には、
発生しうる状況をできるだけ多く考え、
さまざまな状況下でデバッグを行うことが重要である。


\section{課題3-3-2}

\subsection{課題内容}
課題3-3-1で作成した myalarm()を利用して、
課題 2 で作成した simple-talk-clientプログラムにタイムアウト機能を実装せよ。
作成するプログラムは以下の条件を満たす。

\begin{enumerate}
\item 一定時間入出力がない場合、メッセージを出力してプログラムを終了する。
\item シグナルハンドラ内では、``非同期安全な関数''のみを利用する。
\item プログラムを終了する前にきちんと後始末する。
  ソケットの close など、必要な後始末をしてからプログラムを終了する。
\end{enumerate}

\subsection{仕様}
simple-talk-client自体の仕様は省略し、
今回の課題で追加した仕様のみ記述する。

\begin{itemize}
\item ホストに接続した時、標準入力から入力があった時、ソケットから受信した時に、
  タイマーを設定する。
\item タイマーをセットしてから、設定した時間が経つと、タイムアウトフラグが立つ。
\item select()関数の入力監視が終了した時にタイムアウトフラグが立っていれば、
  タイムアウトしたことを標準出力に通知し、通信相手に空データを送信し、
  ソケットを閉じてプログラムを終了する。
\end{itemize}

\subsection{ソースコード}
\lstinputlisting[caption=simple-talk-client2, label=sm]
{simple-talk-client2.c}

\subsection{実装方法}
今回の課題で追加した部分のみ解説する。


\paragraph{シグナルハンドラを設定(76行目)}
まず、シグナルハンドラ設定する。
SIGALRMを受け取った時にtimeout()関数を実行するように設定する。
timeout()関数は60行目で定義されていて、timeoutFlagという変数を1にセットする関数である。

\paragraph{タイマーをセット(110行目)}
ホストへの接続が完了した後、
myAlarm()関数を呼び出して1回目のタイマーをセットする。

\paragraph{タイマーを再セット(126行目)}
標準入力またはソケットからデータを受信した後には、
タイマーを再セットする。
これにより、データを受信するたびにタイマーのカウントをリセットすることができる。

\paragraph{タイムアウト処理(151行目)}
タイマーが実行されてから一定時間が経過し、
SIGALRMが送信されると、
timeoutFlagが1となる。
この時にはタイムアウト処理を行う。
まず、自身の端末に、タイムアウトしたことを通知メッセージを送信する。
さらに、通信相手に空データを送信し、サーバーとの接続を切断する。
最後にソケットを閉じて、プログラムを終了する。
以上の処理をおこなえば、正しく通信を切断し、プログラムを終了することができる。

\subsection{実行結果}
演習室の端末で、今回改造したsimple-talk-client2.exeと、
課題2で作成したsimple-talk-server.exeを実行した結果と以下に示す。

\begin{screen}
\begin{verbatim}
exp172% ./simple-talk-client2.exe exp111
Connected to [exp111.exp.ics.es.osaka-u.ac.jp]
asdfg
client asdfg
qwert
client qwert
TimeOut!

exp111% ./simple-talk-server.exe
Conneced to [exp172.exp.ics.es.osaka-u.ac.jp]
exp172.exp.ics.es.osaka-u.ac.jp asdfg
exp172.exp.ics.es.osaka-u.ac.jp qwert
exp172.exp.ics.es.osaka-u.ac.jp closed
\end{verbatim}
\end{screen}

simple-talk-client2.exeを実行した結果、
最後に文字を入力してから10秒後にタイムアウトが発生した。
その結果、simple-talk-server側では、
通信が終了したことが示されていることから、
終了処理を正しく実装できていることがわかる。

従って、このプログラムは仕様を満たしている。

\subsection{考察}
課題3-3-1では、
myAlarm()関数の中のみを改造したので、
この関数を別のプログラムに移植するのは非常に簡単であった。

この課題で特に注意しなければならないことは、
通信を切断する際には、
通信相手に空データを送信しなければならないということである。
この処理を行わないと、
通信が切断されたことを通信相手が認識できなくなってしまう。
今回のようなタイムアウト処理を行う際には、
正常に処理が終了した際にはどのような処理が行われているのかを予めまとめておくことが重要である。

また、このプログラムは、
select()関数の処理によって1秒間の待機が発生しているため、
\verb+SIGALRM+が送信された後に即座にタイムアウトが発生するわけではない。
今回はタイムアウトが起こるまでの時間の誤差は1秒以内に収まるため、
さほど問題ではないと考えられるが、
待機時間がもっと長時間になった場合は、
別の方法を採用しなければならない。

\newpage
\section{発展課題1}

\subsection{課題内容}
セマフォを利用して、バリア同期(プロセスの待ち合わせ)を実現せよ。
バリア同期は、``全てのプロセスが特定の処理に到達するまで、
先に到達したプロセスは待機する ''という機能である。
任意のプロセス数 に対してバリア同期を実現するプログラムを作成すること。


\subsection{仕様}
filecounter.cを一部改造して、
バリア同期を実現するプログラム、barrier.cを作成した。
その仕様を以下に示す。

\begin{itemize}
\item プログラムを実行すると、セマフォを作成し、任意の数の子プロセスを作成する。
\item i番目に生成された子プロセスは、i秒間待機して、メッセージを出力する。
  普通に実行すると、1秒毎にメッセージが出力されるはずであるが、
  この部分にバリア同期を用いて、メッセージが同時に表示されるようにする。
\end{itemize}

\subsection{ソースコード}
\lstinputlisting[caption=barrier.c, label=ba]
{barrier.c}

\subsection{実装方法}
セマフォ操作関数mySemop()について詳しくは、
\ref{semop}章ですでに説明してあるため、
記述は省略する。

また、セマフォの生成や、子プロセスの生成などの流れも、
\ref{semop}章の説明と同一であるため、
今回は主に子プロセス内の処理について説明する。


\paragraph{子プロセスの処理(51行目)}

\subparagraph{i秒間の待機}
まず、i回目に生成された子プロセスは、i秒間待機する。
これにより、各子プロセスが次の処理に到達する時間をずらすことが出来る。

\subparagraph{セマフォの値を1増やす}
ここからバリア同期の処理を開始する。
mySemop()の第3引数に1を指定して、セマフォの値を1増やす。
これにより、セマフォの値は、
先に到達したプロセスの数を示していることになる。

\subparagraph{待機処理}
semctl()関数でセマフォの値を読み取り、処理を分岐する。

セマフォの値がNUMPROCSと等しい時は、
全てのプロセスが到達していることになるので、
セマフォの値を0にして、他のプロセスの待機を解除する。

セマフォの値がNUMPROCSと等しくない場合は、
まだ到達していないプロセスが存在していることになるので、
セマフォが0になるまで待機する。
mySemop()の第3引数を0にすると、
sem\_opが0になった状態で、semop()が実行される。
これにより、セマフォが0になるまで待機することができる。
待機していると、
最後に到達したプロセスがセマフォの値を0にしてくれるので、
次の処理に進むことができる。
以上の処理を行うと、
バリア同期したい処理を同時に実行することが出来る。

\subsection{実行結果}
barrier.exeを実行した結果を以下に示す。
実行には、同一ディレクトリ内に「semaphore」という名前のファイルが必要である。

\begin{screen}
\begin{verbatim}
% ./barrier.exe
Process 3 executed.
Process 1 executed.
Process 0 executed.
Process 2 executed.
% ./barrier.exe
Process 3 executed.
Process 1 executed.
Process 2 executed.
Process 0 executed.
% ./barrier.exe
Process 2 executed.
Process 1 executed.
Process 0 executed.
Process 3 executed.
\end{verbatim}
\end{screen}

プログラムの出力結果を見ると、
出力の順番が毎回異なっていることがわかる。
これは、バリア同期によって、
バリア同期したい処理が同時に実行されていることを示している。

従って、このプログラムは仕様を満たしている。

\subsection{考察}
バリア同期をセマフォを用いて実装する際には、
「先に到着したプロセスは処理を待機し、
最後に到着したプロセスは他のプロセスの処理を開始させる」
という動作をイメージする事により、
簡単に実装することが出来た。

最初の課題で作成したmySemop()関数を有効活用することにより、
プログラムの記述も素早く行うことが出来た。

このバリア同期は、例えば、
「数値計算を分散して行い、
得られた結果を最後に足し合わせる」
といった計算に役立てることができるだろう。


\section{発展課題3}

\subsection{課題内容}
セマフォやシグナルを用いて、
2 つのプロセスが交互に動作するプログラムを作成せよ。
プログラムが実行されたら 2 つのプロセス (A と B とする) に fork する。
A は ``A[1]~A[n] まで''、B は``B[1]~B[100] まで''をprintf などで出力する。
ただし、A[i] と B[i] が交互に出力されるよう、プロセス 間の調停を行う。


\subsection{仕様}
発展課題1で作成したbarrier.cを一部改造して、
交互実行を実現するプログラム、turn.cを作成した。
その仕様を以下に示す。

\begin{itemize}
\item プログラムが実行されたら、2つのセマフォと2つのプロセス(P0とP1とする)を生成する。
\item 交互実行を行い、P0 は ``P0[1]~P0[n] まで''、
  P1 は``P1[1]~P1[100] まで''をprintfで交互に出力する。
  P0[i]の次にP1[i]が実行される。
\end{itemize}

\subsection{ソースコード}
\lstinputlisting[caption=turn.c, label=tr]
{turn.c}

\subsection{実装方法}
プロセスの生成など基本的な構造はbarrier.cと同じであるため、
barrier.cとくらべて変化があった部分のみ説明する。

\paragraph{セマフォの生成}
セマフォの生成方法は、これまでとほとんど同じである。
今回は、2つのセマフォを使用したいため、
semget()の第2引数に2を指定して、
セマフォを2つ生成する。
sem\_numが0のセマフォはプロセスP0を制御するセマフォ、
sem\_numが1のセマフォはプロセスP1を制御するセマフォとする。

semctl()で、
プロセスP0のセマフォの値を1に、
プロセスP1のセマフォの値を0に設定しておく。

\paragraph{交互実行処理}
各プロセスは、まず、自分のセマフォの値を1減らす。
この結果、セマフォの値がマイナスになると、
セマフォが0になるのを待機する。
最初、プロセスP0 のセマフォの値が1なので、
プロセスP0は実行されるが、
プロセスP1 のセマフォの値は0なので、
この処理の結果セマフォの値が-1になり、
待機する。
この結果、まずはプロセスP0のみが実行される。
プロセスP0が、P0[0]を出力した後は、
プロセスP1のセマフォの値を1増やす。
これにより、プロセスP1の待機が解除され、
P1[0]が出力される。
semOther()関数は、引数に1を指定した時0が、0を指定した時1が返ってくる関数である。
これにより、別のプロセスのセマフォを操作することができる。

このように、1.自分のセマフォを1減らす。2.出力を実行する。3.相手のセマフォを1増やす。
という処理を2つのプロセスが繰り返し実行することによって、
交互実行が実現できる。

\subsection{実行結果}
turn.exeを何回か実行した結果を以下に示す。

\begin{screen}
\begin{verbatim}
% ./turn.exe
P0 [ 0 ]
P1 [ 0 ]
P0 [ 1 ]
P1 [ 1 ]
P0 [ 2 ]
P1 [ 2 ]
P0 [ 3 ]
P1 [ 3 ]
P0 [ 4 ]
P1 [ 4 ]
P0 [ 5 ]
P1 [ 5 ]
P0 [ 6 ]
P1 [ 6 ]
P0 [ 7 ]
P1 [ 7 ]
P0 [ 8 ]
P1 [ 8 ]
P0 [ 9 ]
P1 [ 9 ]
\end{verbatim}
\end{screen}
今回は紙面の都合上、
出力する数字の数を10個にした。
何回か実行しても、2つのプロセスが交互に出力していた。
出力する数字の数を増やしても、
正しく実行されることは明らかである。

従って、このプログラムは仕様を満たしている。

\subsection{考察}
交互実行の動作は、
「自分の処理が完了したら、
相手の処理を開始させる」
という処理を繰り返すことで実装することが出来た。
セマフォは複数獲得することができるので、
2つのセマフォを操作することは容易であった。

今回は2つのプロセスの交互実行を実装したが、
操作するセマフォの数を増やせば、
3つ以上のプロセスに順番に処理を行わせることも可能だろう。

発展課題1と3を通して、
セマフォは単純な排他制御を実装するだけではなく、
工夫次第でさまざまな制御に応用することができるということがわかった。




\section{感想・意見}

今回の課題では、
セマフォやパイプ、シグナルハンドラなど、
今まで存在すら知らなかった機能や、
自分で制御できるとは思わなかった機能を使うことによって、
C言語によるプログラミングの奥深さを知ることが出来ました。
ただ、間違ったプログラムを書いてしまった結果、
全てのプロセスを終了させてしまい、
OSをシャットダウンさせてしまうという事態が起こってしまいました。
さまざまな処理を自由に記述することができるようになった反面、
このようなことが起こりうるということも念頭において、
プログラミングを行わなければならないと思いました。

今回の課題は、
課題数は多いものの、
実装自体は簡単なものばかりでした。
その結果、授業時間の半分以上をレポートの記述に費やすことになりました。
レポートの記述がもう少し少なくなるような問題構成だとありがたかったです。

\end{document}