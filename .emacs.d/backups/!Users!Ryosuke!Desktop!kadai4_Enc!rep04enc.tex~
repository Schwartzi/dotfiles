\documentclass{jsarticle}
\title{情報科学演習C 第2回レポート課題} % 題目
\author{谷村亮介}                    % 提出者名
\date{平成25年7月4日(木)}            % 提出日

% \課題名{ネットワークプログラミングの基礎}   % 課題名
% \担当教官{内山彰}                       % 担当教官名
% \所属{ソフトウェア科学コース}             % 自分の所属するコース名などを指定する.
% \学年{3年}                             % 学年
% \学籍番号{09B11044}                    % 学籍番号
% \email{u549298j@ecs.osaka-u.ac.jp}    % 電子メールのアドレス

\usepackage{ascmac}
\usepackage{here}
\usepackage{txfonts}
\usepackage{listings, jlisting}
\usepackage{color}
\usepackage[dvips]{graphicx}


\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{colFunc}{rgb}{1,0.07,0.54}
\definecolor{CadetBlue}{cmyk}{0.62,0.57,0.23,0}
\definecolor{Brown}{cmyk}{0,0.81,1,0.60}
\definecolor{colID}{rgb}{0.63,0.44,0}


\renewcommand{\lstlistingname}{リスト}
\lstset{language=c,
  backgroundcolor={\color[gray]{.95}},%
  basicstyle=\sffamily\scriptsize,
  keywordstyle={\bfseries \color{OliveGreen}},
  commentstyle={\itshape \color{Brown}},
  stringstyle={\ttfamily \color{CadetBlue}},
  frame=tRBl,
  framesep=5pt,
  showstringspaces=false,
  numbers=left,
  stepnumber=1,
  numberstyle=\sffamily\tiny,
  tabsize=2
}

\begin{document}
\tableofcontents
\newpage



\section{課題内容}

\subsection{課題4-1}

手順書3章に示されたプロトコル仕様にしたがってチャットプログラム
(クライアントおよびサーバプログラム) を作成する。
作成したチャットプログラムは、サンプルプログラムとの通信が正しくできなければならない。

\subsection{課題4-2}

chatserver、chatclient を拡張し、
便利と思われる機能を追加する。

今回追加した機能は以下のとおりである。

\begin{itemize}
\item 各発言の先頭にユーザ名以外に、発言時刻が表示される機能
\item サーバへ"\verb+/list\n+"という文字列を送ると
  現時点の全参加者のユーザ名リストが返されるという機能
\item [難] 一定時間発言のないユーザを強制離脱させる機能
\end{itemize}


\section{解答 -- 課題4-1・課題4-2 -- }

\subsection{実装方法  -- chatclient.c --}
\label{semop}
このプログラムの実装方法を以下に示す。
なお、各段落の見出しは、付録に示したソースコード中の同じ文に該当する。
これ以降の「実装方法」の章でも同じ記述方法を採用している。


\paragraph{c1 初期状態}
まず始めに引数の数を確認する。
正しく動作させるためにはプログラムに2つの引数を与える必要があるので、
それ以外の時はエラーメッセージを出力してプログラムを終了する。

次に、サーバーと通信するためのソケットを作成する。
プロトコルにはTCPを選択し、使用するポートには10140を指定する。

第1引数の文字列からIPアドレスを取得し、
サーバーに接続する。
接続が確立できたら、次の状態に移る。


\paragraph{c2 参加}
サーバーから文字列を受信し、
それが``\verb+REQUEST ACCEPTED\n+''であるかを確認する。
サーバーから送られてきた文字列にはヌル文字が含まれていないため、
strncmp()を用いて、ヌル文字以外を比較する必要がある。

サーバーから送られてきた文字列が
``\verb+REQUEST ACCEPTED\n+''であれば、
それを標準出力に出力し、次の状態に移る。
それ以外であれば、エラーが発生したことを通知するとともに、
受信した文字列を標準出力に出力し、状態c6に移る。


\paragraph{c3 ユーザー名登録}
サーバーにユーザー名を送信するために、
まずは第2引数に与えられた文字列を加工する。
引数の文字列を作業用の変数nameにコピーし、
nameの末尾に``\verb+\n+''を付加する。
そして、write()でサーバーに送信する。

状態c2の場合と同様にして、
サーバーから返ってきた文字列が
``\verb+USERNAME REGISTERED\n+''
であるか確認する。
そうであれば、次の状態に移り、
異なる場合は状態c6に移る。

なお、プロトコル仕様では、
「ユーザ名は英数字、ハイフン (``-'') およびアンダースコア (``\_'') のみから成る文字列とする」
と規定されている。
このプログラムでは、ユーザー名が仕様に従っているかは判定せず、
必ず正しいユーザー名が入力されると仮定して処理を行なっている。
もし誤ったユーザー名が入力されても受理してしまうが、
この性質はサンプルクライアントでも同様であったから、
今回は問題にならないはずである。


\paragraph{c4 メッセージ送受信}
サーバーへのユーザー名登録が完了したら、
全2重通信を利用してチャットの動作を開始する。

標準入力と、作成したソケットを、
入力を監視するファイル記述子として、
変数rfdsにセットする。
監視する待ち時間は1秒に設定する。

次に、select()を用いて、
標準入力とソケットからの受信を同時に監視する。
標準入力から入力があった時は、
rfdsの中に0がセットされている。
FD\_ISSET()を用いると、これを確認することができる。
この時には標準入力から文字列を読み込み、
そのままサーバーに送信する。

同様にして、ソケットから確認したことがわかったら、
ソケットから文字列を読み込み、
そのまま標準出力に出力する。

EOFを読み込むまでこの作業を繰り返し実行すると、
チャットクライアントとしての機能を得ることができる。


\paragraph{c5 離脱}
read()で文字列を読み取った結果、
それがEOFであれば、返り値が0になる。
この場合は状態c4のループを抜け、
ソケットをcloseしてプログラムを終了する。


\paragraph{c6 例外処理}
状態c2およびc3で、正しい文字列を受信できなかった時には、
exception()関数が呼び出される。
この関数は、ソケットをcloseした後エラーメッセージを出力し、
プログラムを強制終了する。



\subsection{実装方法 -- chatserver.c --}

\paragraph{s1 初期状態}
まずは、クライアント情報を記録するリストを初期化する。
今回は、クライアントのソケットとユーザー名をまとめて扱うために、
memList構造体を作成した。
この構造体を、配列list[]として\verb+MAXCLIENT+の個数分作成し、
配列の要素が空であることを示すために、
csockに-1を入れておく。
参加クライアント数k=0とする。
なお、参加者を管理するために配列ではなく単方向リストなどを用いる方法も考えられるが、
今回は実装のシンプルさを優先して、配列で管理することにした。

次に、ユーザーのタイムアウト機能のために使用するパイプを生成しておく。

クライアントの場合と同様にして、
クライアントを受け付けるためのソケットを生成する。
プロトコルはTCP、使用ポートは10140である。
待ち受けクライアント数の最大値は、
\verb+MAXCLIENTS+としておいた。

ソケットを作成できたら、
次の状態に移る。


\paragraph{s2 入力待ち}
FD\_SET()で、タイムアウト用パイプ、
クライアント受付用ソケット、参加者のソケットを
集合rfdsに追加する。
参加者のソケットを追加する際には、
配列の要素が空でないもの、すなわちcsockの値が-1でないものを追加する。

select()を用いて、ソケットとパイプからの受信を同時に監視する。
この関数の第1引数には、rfdsに追加された値の最大値+1を指定する必要があるが、
今回は十分大きい値と考えられる10を指定した。

ここで注意しなければならないことは、
select()が実行された結果、
rfdsの値は書き換えられてしまうため、
毎回rfdsの値をセットし直さなければならないということである。

\paragraph{s3 入力処理 }
FD\_ISSET()を使って入力があったソケットを判別し、
入力があったすべてのソケットとパイプに対して入力処理を行う。

接続要求があった場合は状態s4に、
クライアントから入力があった場合は状態s5に移る。


\paragraph{s4 参加受付}
接続要求があったときには、
接続をaccept()する。
現在の参加クライアント数kの値が\verb+MAXCLIENTS+よりも大きかった場合は、
``\verb+REQUEST REJECTED\n+''
をクライアントに送信し、ソケットを閉じる。
そうでない時は、
``\verb+REQUEST ACCEPTED\n+''
を送信し、次の状態に移る。

\paragraph{s5 ユーザー名登録}
クライアントからはユーザー名が返ってくるはずなので、
これを読み取る。
受信した文字列の末尾には\verb+\n+があるので、
それを\verb+\0+に置き換える。
この時点では、ユーザー名の文字数が異常に長い場合がある。
そこで、\verb+MAXNAME+番目の文字も\verb+\0+に置き換えることによって、
長すぎる部分を無視する。
サンプルサーバーではユーザー名の最大値は99であったが、
今回は\verb+NAXNAME+=20とした。
その後、ユーザー名を作業用の変数にコピーする。

ユーザー名の文字列処理の過程の例を、以下に示す。

\begin{screen}
\begin{verbatim}
rbuf = ABCDEFGHIJKLMNOPQRSTUXYZ\n
  ↓ \nを\0に置き換え
rbuf = ABCDEFGHIJKLMNOPQRSTUXYZ\0
  ↓ 21文字目を\0に置き換え
rbuf = ABCDEFGHIJKLMNOPQRST\0XYZ\0
  ↓ unにコピー
un   = ABCDEFGHIJKLMNOPQRST\0
\end{verbatim}
\end{screen}

続いて、同一のユーザー名がすでに登録されているかどうかを
確認する。
strcmp()を用いて、list[].nameの中身と1つづつ比較していき、
同じユーザー名が存在する場合にはフラグを立てる。

フラグがたった時には、
``\verb+USERNAME REJECTED\n+''
をクライアントに送信し、
ソケットを閉じる。
フラグが立っていないときには、
``\verb+USERNAME REGISTERED\n+''
を送信する。
list[]の開いている部分、
すなわちlist[].csock=1の部分を探し、
そこにソケットとユーザー名を記録する。

最後にkの値を1増やし、
状態s3に戻る。

\paragraph{s5 メッセージ配信}
登録したクライアントのどれかからメッセージを受信した時には、
その文字列を読み込む。
EOFが送られてきた時、
すなわち





\subsection{実行結果}
filecounter.exeの実行結果を以下に示す。
このプログラムは何回も実行したが、
紙面の都合上、2回分の実行結果を示す。

\begin{screen}
\begin{verbatim}
% ./filecounter.exe
count = 1
count = 2
count = 3
count = 4
% cat counter
4
% ./filecounter.exe
count = 1
count = 2
count = 3
count = 4
% cat counter
4
\end{verbatim}
\end{screen}


プログラムを何回実行しても、
counterの中身は最終的に4になっている。
従って、このプログラムは仕様を満たしている。

なお、セマフォの生成に失敗した際などの、
エラーメッセージの出力に関しては、
再現が難しいため、正しく実装できているかは実際に確認していない。

\subsection{考察}
このプログラムにとりかかる時、
セマフォの仕組み自体を理解するのは容易であったが、
C言語での実装は、やや癖があり、正しく実装することが難しかった。
これに対しては、
セマフォを操作するための関数を自分で用意したことで、
より簡単に操作をすることが可能になった。
自分が操作したい内容に応じて関数をカスタマイズすることで、
より使いやすいセマフォ操作を実現することが出来た。
今後、このような新たな機能を利用するときには、
積極的に関数化し、自分にとって扱いやすいものにしていくことが重要だと考えられる。

今回セマフォを使用していて疑問に思ったことは、
セマフォのインクリメントやデクリメントもクリティカルセクションに該当するのではないのか、
ということである。
これについて詳しく調べてみると、
セマフォのインクリメントなどには、
「デッカーのアルゴリズム」などの排他制御アルゴリズムが用いられているようであった。
このように、適切な排他制御が行われているため、
セマフォを使えばシンプルなWAIT、SIGNAL命令だけで排他制御を行うことができるのである。
今後、プロセス間で排他制御を行う際には、
セマフォを積極的に利用して行きたいと思った。

\newpage
\section{課題3-2-1}

\subsection{課題内容}
指導書4.1章のpipe.c を拡張し、双方向パイプのプログラム two-way-pipe を作成せよ。

\subsection{仕様}
このプログラムの引数の与え方と、
仕様を以下に示す。

\begin{screen}
  {\bf two-way-pipe} MessageToParent MessageToChild
\end{screen}

\begin{itemize}
\item このプログラムは2つの引数をとる、引数の数が足りないときは、エラーを出力する。
\item 子プロセスと2つのパイプを生成する。
\item パイプを利用して、第1引数の文字列を子プロセスから親プロセスへ渡し、
  同時に、第2引数の文字列を親プロセスから子プロセスに渡す。
\item 各プロセスは、送られてきた文字列を同時に出力する。
\end{itemize}

\subsection{ソースコード}
\lstinputlisting[caption=two-way-pipe.c,label=two]
{two-way-pipe.c}

\subsection{実装方法}

\paragraph{引数の確認}
引数の数が正しいか確認する。
引数が2つでないときにはエラーを出力してプログラムを終了する。

\paragraph{パイプと子プロセスの生成}
pipe()関数で2つのパイプを生成する。
親から子へのパイプを「fd\verb+_+PtoC」、
子から親へのパイプを「fd\verb+_+CtoP」と名付ける。

fork()関数で、子プロセスを1つ生成する。

\paragraph{子プロセスの処理}
まず、close()関数で、
親から子へのパイプに書き込みすることと、
子から親へのパイプから読み出しすることを禁止する。

次に、write()関数で、第1引数の文字列を子から親へのパイプに書き込む。
そして、read()関数で、親から子へのパイプに書き込まれた内容を読み出し、
printf()関数で、標準出力に出力する。

これで、子プロセスの処理は終了である。

\paragraph{親プロセスの処理}
親プロセスの処理の流れは、
子プロセスのものと同じである。
closeするパイプと、
書き込み、読み出しするパイプを、
子プロセスの場合と逆にすれば良い。

メッセージを出力したら、
wait()関数で子プロセスの終了を待機し、
プログラムを終了する。

\subsection{実行結果}
two-way-pipe.exeを数回実行した結果を以下に示す。

\begin{screen}
\begin{verbatim}
% ./two-way-pipe.exe FROMCHILD FROMPARENT
Message from Parent process:    FROMPARENT
Message from child process:     FROMCHILD
$ ./two-way-pipe.exe FROMCHILD FROMPARENT
Message from child process:     FROMCHILD
Message from Parent process:    FROMPARENT
\end{verbatim}
\end{screen}


このプログラムを実行した結果、
親子間で正しくメッセージをやりとりできている。
また、何回か実行すると、親の処理が先に実行されていたり、
子の処理が先に実行されていたりすることから、
親プロセスと子プロセスの処理は同時に実行されていることがわかる。

従って、このプログラムは仕様を満たしている。

\subsection{考察}

このプログラムの作成は、
極めて簡単であった。
パイプによるプロセス間通信で注意しなければならないことは、
同じプロセスが1つのパイプに対して読み込みと書き込みの両方をおこなってはならない、ということである。
そのため、プロセス間で双方向に通信したい際には、
今回のようにパイプを2つ用意しておく必要がある。

このことを守っておけば、
あとはファイルに読み書きするのと同じようにすれば、
プロセス間通信を行うことができるため、
パイプは大変有効な手段であるといえる。
パイプを有効活用すれば、
マルチプロセスプログラミングの幅をより広げることができるであろう。


\section{課題3-2-2}

\subsection{課題内容}
CLE の課題 3 に添付したマージソートを行うプログラム mergesort.c を拡張し、
並列版 マージソートを作成せよ。

さらに,配列のサイズ N(\verb+NUM_ITEMS+)を増やした場合の動作を確認せよ。
N が大きくなっても正常に動作するよう、プログラムを改良せよ。

\subsection{仕様}

今回は、mergesort.c内の関数mergeSort()のみを改造して、
並列版マージソートmergesortPipe.cを作成した。
ここでは、改造したmergeSort()関数の仕様のみを記す。

\begin{itemize}
\item 最初に、プロセス間通信用のパイプを生成し、子プロセスを生成する。
\item 子プロセスは配列の前半分を、親プロセスは配列の後半分をマージソートする。
\item パイプを利用して、子プロセスでソートした配列を親プロセスへ渡す。
\item 親プロセスは、2つの部分配列をマージし、結果を得る。
\end{itemize}

\subsection{ソースコード}
\lstinputlisting[caption=mergesortPipe.c,label=mg]
{mergesortPipe.c}

\subsection{実装方法}
mergeSort()の実装方法のみ解説する。

\paragraph{パイプと子プロセスの生成}
pipe()関数でパイプを生成する。
また、fork()関数で、子プロセスを1つ生成する。

\paragraph{子プロセスの処理}
まず、close()関数で、
パイプから読み出しすることを禁止する。

次に、\verb+m_sort(numbers, temp, 0, mid)+を実行することで、
配列の前半分をマージソートする。
ソートが完了したら、write()関数で、ソートした配列の要素を1つずつパイプに書き込む。

これで、子プロセスの処理は終了である。

\paragraph{親プロセスの処理}
まず、close()関数で、
パイプに書き込むことを禁止する。

子プロセスの場合と同様にして、
配列の後半分をマージソートする。

ソートが完了したら、
子プロセスがソートした配列の要素を1つずつパイプから読み取り、
配列の前半分にコピーしていく。

その後、配列をマージすれば、結果を得ることができる。
wait()関数で子プロセスの終了を見届けると、
関数の処理が完了する。


例として、配列が10個の場合の、具体的な処理の流れを以下に示した。

\begin{screen}
\begin{verbatim}
3 5 7 4 9 1 8 2 0 6
  ↓プロセス生成
親プロセス             子プロセス
3 5 7 4 9 1 8 2 0 6   3 5 7 4 9 1 8 2 0 6
  ↓マージソート(後)       ↓マージソート(前)
3 5 7 4 9|0 1 2 6 8   3 4 5 7 9|1 8 2 0 6
  ↓パイプで送受信
3 4 5 7 9|0 1 2 6 8
  ↓マージ
0 1 2 3 4 5 6 7 8 9
\end{verbatim}
\end{screen}


\subsection{実行結果}
mergesortPipe.exeを実行した結果の一部を以下に示す。

\begin{screen}
\begin{verbatim}
% ./mergesortPipe.exe
Done with sort.
1844796
2633903
2977667
4850017
7204030
8818600
13410583
22074909
22479562
26886988
---(略)---
\end{verbatim}
\end{screen}


紙面の都合上、
出力結果の一部のみを掲載しているが、
配列の数を100000個にしても、
プログラムは停止せずに結果を出力することが出来た。

また、出力結果をsortコマンドなどでソートし、
diffコマンドでそれと出力結果とを比較したところ、
差異は見られなかったことから、
ソートは正しく行うことができていると分かる。

従って、このプログラムは仕様を満たしている。

\subsection{考察}
今回の課題では、
ソートのプログラムは予め与えられていたため、
関数の役割さえ理解すれば、
実装の方針を立てるのは容易であった。
この課題で苦労したことは、
配列のサイズが大きい時に、
配列を分割してパイプに書き込む必要がある、ということである。
ここでは配列の要素を1つずつパイプに書き込むことで、
この問題を回避した。
要求された仕様は満たしているものの、
これでは実行効率があまり良くない。
配列を一定のサイズで分割し、
ブロックごとにやり取りすれば、
より実行効率が上がるかもしれない。
今回は、処理を高速化することは要求されていなかったため、
実行速度については評価しなかったが、
実行速度が求められている場合には、
この部分の処理を見直す必要があるだろう。

\newpage

\section{課題3-3-1}

\subsection{課題内容}
alarm() を使用せずに、同等の機能を実現する myalarm() をマルチプロセスを用いて実装せよ。
alarm.c の関数 myalarm() の定義を書き換えて、alarm() を使わずに同等の機能を実現する。
その際、以下の条件を満たす必要がある。

\begin{enumerate}
\item 書き換えて良いのはmyalarm()の中だけである。
\item 呼び出し元のプロセスの処理は、myalarm()を呼び出したらすぐに戻ってくること。
\item マルチプロセスを利用して、指定した秒数が経過したら呼び出し元のプロセスに \verb+SIGALRM+ を送信する。
  その際、子プロセスがゾンビプロセスとなって残らないように注意する。
\item すでにタイマーがセットされていた場合、そのタイマーを削除して新しいタイマーを設定する
  (myalarm() を呼び出すたびにプロセスが増えていってはならない)。
\end{enumerate}

\subsection{仕様}
今回は、myalarm()関数のみの仕様を示す。

\begin{itemize}
\item 最初に、タイマー機能を実現するための子プロセスを生成する。
\item 子プロセスは、関数の引数で指定された秒数だけ待機したあと、
  親プロセスが存在する場合には、\verb+SIGALRM+を送信する。その後プロセスを終了する。
  親プロセスが何らかの原因で存在しない場合には、何もせずに終了する。
\item 親プロセスは、既存の子プロセスを削除し、新たに生成した子プロセスのPIDを保存する。
  その後、子プロセスの終了を無視する処理を施し、関数を終了する。
\end{itemize}

\subsection{ソースコード}
\lstinputlisting[caption=myAlarm.c,label=my]
{myAlarm.c}

\subsection{実装方法}

\paragraph{子プロセスの生成}
始めに、folk()関数を用いて子プロセスを生成する。
この子プロセスが、タイマー機能を実現する。

\paragraph{子プロセスの処理}
生成された子プロセスは、
myAlarm()関数の引数で指定された秒数だけ待機する。
その後、親プロセスが存在するか確認する。
kill(getppid(), 0)の返り値が0の時、
親プロセスが存在していることがわかる。
返り値がそれ以外だった場合は、
強制終了などによって親プロセスが存在していないので、
何もせずに子プロセスを終了する。

親プロセスが存在していた場合は、
親プロセスにSIGALARMを送信し、
子プロセスを終了する。

\paragraph{親プロセスの処理}

\subparagraph{◯既存の子プロセスを削除}

myAlarm()関数が2回目以降に呼び出された場合は、
前回生成された子プロセスを削除しなければならない。
前の子プロセスのPIDは、oldPidという変数に保存されている。
この変数は、static修飾子をつけて宣言されているため、
関数が終了した後も、値が残り続ける。
前の子プロセスが存在するとき、
すなわちoldPidの値が0でないときには、
そのPIDに対して\verb+SIGTERM+を送信することで、子プロセスを削除する。

\subparagraph{◯作成した子プロセスのPIDを保存}
今回作成した子プロセスのPIDを、
oldPidに保存しておく。
これにより、次にmyAlarm()を呼び出した時に、
前の子プロセスのPIDを知ることができる。

\subparagraph{◯子プロセスの終了を無視}
signal(SIGCHLD, SIG\_IGN)を実行することで、
\verb+SIGCHLD+というシグナルを無視することができる。
\verb+SIGCHLD+は、子プロセスの終了を親プロセスに通知するシグナルであり、
これを無視する設定にすることで、子プロセスの終了を監視しなくても、
ゾンビプロセスになるのを防ぐことができる。

この処理を実行した後は、関数を終了する。


\subsection{実行結果}
myAlarm.exeを実行した結果を以下に示す。
タイムアウトまでの時間は10秒に設定した。
timeコマンドを使用し、実行にかかった時間を示した。

\begin{screen}
\begin{verbatim}
% time ./myAlarm.exe
a
echo: a
s
echo: s
d
echo: d
This program is timeout.
./myAalarm.exe  0.00s user 0.00s system 0% cpu 13.096 total
% time ./myAlarm.exe
a
echo: a
s
echo: s
^C
./myAalarm.exe  0.00s user 0.00s system 0% cpu 3.119 total
% ps
  PID TTY           TIME CMD
 6555 ttys000    0:04.55 -zsh
\end{verbatim}
\end{screen}


このプログラムを実行した結果、
最後に文字を入力してから10秒後にタイムアウトが発生した。
このことから、前に設定したアラームは正しく削除できていることがわかる。

また、プログラムを途中で強制終了した場合は、
その後に子プロセスから\verb+SIGALRM+が送信されていない。

psコマンドを実行した結果、
ゾンビプロセスは存在しなかった。

従って、このプログラムは仕様を満たしている。

\subsection{考察}

このプログラムの作成にあたって困難だったことは、
子プロセスのプロセスIDを、
関数が終了した後も保持しておくことであった。
今回は、static修飾子をつけた変数を使用することで、
この問題を解決した。
関数の中で大域変数を作ってしまうのは、
あまり良い方法ではないが、
今回の要求仕様を満たすためにはこの方法が適切であると考えられる。

プログラムを完成させた後、
要求された仕様を満たしただけでは、
「タイマーをセットした状態で親プロセスが強制終了などで消滅してしまうと、
子プロセスはシグナルの送信に失敗して、エラーを出力してしまう」
という問題が発生することに気づいた。
この問題は、
親プロセスが存在するか確認してから、
親プロセスにシグナルを送ることで解決することが出来た。
このように、複数プロセスを使用するプログラムでは、
単一プロセスのプログラムでは考えられないようなバグが発生してしまうことがある。
今回のようなプログラムをデバッグする際には、
発生しうる状況をできるだけ多く考え、
さまざまな状況下でデバッグを行うことが重要である。


\section{課題3-3-2}

\subsection{課題内容}
課題3-3-1で作成した myAlarm()を利用して、
課題 2 で作成した simple-talk-clientプログラムにタイムアウト機能を実装せよ。
作成するプログラムは以下の条件を満たす。

\begin{enumerate}
\item 一定時間入出力がない場合、メッセージを出力してプログラムを終了する。
\item シグナルハンドラ内では、``非同期安全な関数''のみを利用する。
\item プログラムを終了する前にきちんと後始末する。
  ソケットの close など、必要な後始末をしてからプログラムを終了する。
\end{enumerate}

\subsection{仕様}
simple-talk-client自体の仕様は省略し、
今回の課題で追加した仕様のみ記述する。

\begin{itemize}
\item ホストに接続した時、標準入力から入力があった時、ソケットから受信した時に、
  タイマーを設定する。
\item タイマーをセットしてから、設定した時間が経つと、タイムアウトフラグが立つ。
\item select()関数の入力監視が終了した時にタイムアウトフラグが立っていれば、
  タイムアウトしたことを標準出力に通知し、通信相手に空データを送信し、
  ソケットを閉じてプログラムを終了する。
\end{itemize}

\subsection{ソースコード}
\lstinputlisting[caption=simple-talk-client2, label=sm]
{simple-talk-client2.c}

\subsection{実装方法}
今回の課題で追加した部分のみ解説する。


\paragraph{シグナルハンドラを設定(77行目)}
\verb+SIGALRM+を受け取った時にtimeout()関数を実行するように設定する。
timeout()関数は60行目で定義されていて、timeoutFlagという変数を1にセットする関数である。

\paragraph{タイマーをセット(110行目)}
ホストへの接続が完了した後、
myAlarm()関数を呼び出して1回目のタイマーをセットする。

\paragraph{タイマーを再セット(126行目)}
標準入力またはソケットからデータを受信した後には、
タイマーを再セットする。
これにより、データを受信するたびにタイマーのカウントをリセットすることができる。

\paragraph{タイムアウト処理(151行目)}
タイマーが実行されてから一定時間が経過し、
\verb+SIGALRM+が送信されると、
timeoutFlagが1となる。
この時にはタイムアウト処理を行う。
まず、自身の端末に、タイムアウトしたことを通知するメッセージを送信する。
さらに、通信相手に空データを送信し、サーバーとの接続を切断する。
最後にソケットを閉じて、プログラムを終了する。
以上の処理をおこなえば、正しく通信を切断し、プログラムを終了することができる。

\subsection{実行結果}
演習室の端末で、今回改造したsimple-talk-client2.exeと、
課題2で作成したsimple-talk-server.exeを実行した結果と以下に示す。

\begin{screen}
\begin{verbatim}
exp172% ./simple-talk-client2.exe exp111
Connected to [exp111.exp.ics.es.osaka-u.ac.jp]
asdfg
client asdfg
qwert
client qwert
TimeOut!

exp111% ./simple-talk-server.exe
Conneced to [exp172.exp.ics.es.osaka-u.ac.jp]
exp172.exp.ics.es.osaka-u.ac.jp asdfg
exp172.exp.ics.es.osaka-u.ac.jp qwert
exp172.exp.ics.es.osaka-u.ac.jp closed
\end{verbatim}
\end{screen}

simple-talk-client2.exeを実行した結果、
最後に文字を入力してから10秒後にタイムアウトが発生した。
その結果、simple-talk-server側では、
通信が終了したことが示されていることから、
終了処理を正しく実装できていることがわかる。

従って、このプログラムは仕様を満たしている。

\subsection{考察}
課題3-3-1では、
myAlarm()関数の中のみを改造したので、
この関数を別のプログラムに移植するのは非常に簡単であった。

この課題で特に注意しなければならないことは、
通信を切断する際には、
通信相手に空データを送信しなければならないということである。
この処理を行わないと、
通信が切断されたことを通信相手が認識できなくなってしまう。
今回のようなタイムアウト処理を行う際には、
正常に処理が終了した際にはどのような処理が行われているのかを予めまとめておくことが重要である。

また、このプログラムは、
select()関数の処理によって1秒間の待機が発生しているため、
\verb+SIGALRM+が送信された後に即座にタイムアウトが発生するわけではない。
今回はタイムアウトが起こるまでの時間の誤差は1秒以内に収まるため、
さほど問題ではないと考えられるが、
待機時間がもっと長時間になった場合は、
別の方法を採用しなければならない。

\newpage
\section{発展課題1}

\subsection{課題内容}
セマフォを利用して、バリア同期(プロセスの待ち合わせ)を実現せよ。
バリア同期は、``全てのプロセスが特定の処理に到達するまで、
先に到達したプロセスは待機する ''という機能である。
任意のプロセス数 に対してバリア同期を実現するプログラムを作成すること。


\subsection{仕様}
filecounter.cを一部改造して、
バリア同期を実現するプログラム、barrier.cを作成した。
その仕様を以下に示す。

\begin{itemize}
\item このプログラムは、引数を与えずに実行する。
\item プログラムの実行のためには、「semaphore」という名前のファイルが必要である。
\item プログラムを実行すると、セマフォを作成し、\verb+NUMPROCS+で指定されたの数の子プロセスを作成する。
\item i番目に生成された子プロセスは、i秒間待機して、メッセージを出力する。
  普通に実行すると、1秒毎にメッセージが出力されるはずであるが、
  この部分にバリア同期を用いて、メッセージが同時に表示されるようにする。
\end{itemize}

\subsection{ソースコード}
\lstinputlisting[caption=barrier.c, label=ba]
{barrier.c}

\subsection{実装方法}
セマフォ操作関数mySemop()について詳しくは、
\ref{semop}章ですでに説明してあるため、
記述は省略する。

また、セマフォの生成や、子プロセスの生成などの流れも、
\ref{semop}章の説明と同一であるため、
今回は主に子プロセス内の処理について説明する。


\paragraph{子プロセスの処理(51行目)}

\subparagraph{◯i秒間の待機}
まず、i回目に生成された子プロセスは、i秒間待機する。
これにより、各子プロセスが次の処理に到達する時間をずらすことが出来る。

\subparagraph{◯セマフォの値を1増やす}
ここからバリア同期の処理を開始する。
mySemop()の第3引数に1を指定して、セマフォの値を1増やす。
これにより、セマフォの値は、
先に到達したプロセスの数を示していることになる。

\subparagraph{◯待機処理}
semctl()関数でセマフォの値を読み取り、処理を分岐する。

セマフォの値が\verb+NUMPROCS+と等しい時は、
全てのプロセスが到達していることになるので、
セマフォの値を0にして、他のプロセスの待機を解除する。

セマフォの値が\verb+NUMPROCS+と等しくない場合は、
まだ到達していないプロセスが存在していることになるので、
セマフォが0になるまで待機する。
mySemop()の第3引数を0にすると、
sem\_opが0になった状態で、semop()が実行される。
これにより、セマフォが0になるまで待機することができる。
待機していると、
最後に到達したプロセスがセマフォの値を0にしてくれるので、
次の処理に進むことができる。
以上の処理を行うと、
バリア同期したい処理を同時に実行することが出来る。

\subsection{実行結果}
barrier.exeを実行した結果を以下に示す。
実行には、同一ディレクトリ内に「semaphore」という名前のファイルが必要である。

\begin{screen}
\begin{verbatim}
% ./barrier.exe
Process 3 executed.
Process 1 executed.
Process 0 executed.
Process 2 executed.
% ./barrier.exe
Process 3 executed.
Process 1 executed.
Process 2 executed.
Process 0 executed.
% ./barrier.exe
Process 2 executed.
Process 1 executed.
Process 0 executed.
Process 3 executed.
\end{verbatim}
\end{screen}

プログラムの出力結果を見ると、
出力の順番が毎回異なっていることがわかる。
これは、バリア同期によって、
バリア同期したい処理が同時に実行されていることを示している。

従って、このプログラムは仕様を満たしている。

\subsection{考察}
バリア同期をセマフォを用いて実装する際には、
「先に到着したプロセスは処理を待機し、
最後に到着したプロセスは他のプロセスの処理を開始させる」
という動作をイメージする事により、
簡単に実装することが出来た。

最初の課題で作成したmySemop()関数を有効活用することにより、
プログラムの記述も素早く行うことが出来た。

このバリア同期は、例えば、
「数値計算を分散して行い、
得られた結果を最後に足し合わせる」
といった計算に役立てることができるだろう。


\section{発展課題3}

\subsection{課題内容}
セマフォやシグナルを用いて、
2 つのプロセスが交互に動作するプログラムを作成せよ。
プログラムが実行されたら 2 つのプロセス (A と B とする) に fork する。
A は ``A[1]~A[n] まで''、B は``B[1]~B[100] まで''をprintf などで出力する。
ただし、A[i] と B[i] が交互に出力されるよう、プロセス 間の調停を行う。


\subsection{仕様}
発展課題1で作成したbarrier.cを一部改造して、
交互実行を実現するプログラム、turn.cを作成した。
その仕様を以下に示す。

\begin{itemize}
\item このプログラムは、引数を与えずに実行する。
\item プログラムの実行のためには、「semaphore」という名前のファイルが必要である
\item プログラムが実行されたら、2つのセマフォと2つのプロセス(P0とP1とする)を生成する。
\item 交互実行を行い、P0 は ``P0[1]~P0[n] まで''、
  P1 は``P1[1]~P1[100] まで''をprintfで交互に出力する。
  その結果、P0[i]の次にP1[i]が出力される。
\end{itemize}

\subsection{ソースコード}
\lstinputlisting[caption=turn.c, label=tr]
{turn.c}

\subsection{実装方法}
プロセスの生成など基本的な構造はbarrier.cと同じであるため、
barrier.cとくらべて変化があった部分のみ説明する。

\paragraph{セマフォの生成}
セマフォの生成方法は、これまでとほとんど同じである。
今回は、2つのセマフォを使用したいため、
semget()の第2引数に2を指定して、
セマフォを2つ生成する。
sem\_numが0のセマフォはプロセスP0を制御するセマフォ、
sem\_numが1のセマフォはプロセスP1を制御するセマフォとする。

semctl()で、
プロセスP0のセマフォの値を1に、
プロセスP1のセマフォの値を0に設定しておく。

\paragraph{交互実行処理}
各プロセスは、まず、wait命令を実行して自分のセマフォの値を1減らす。
最初、プロセスP0 のセマフォの値が1なので、
プロセスP0は実行されるが、
プロセスP1 のセマフォの値は0なので、
この処理の結果セマフォの値が-1になり、
待機する。
この結果、まずはプロセスP0のみが実行される。
プロセスP0が、P0[0]を出力した後は、
signal命令を実行してプロセスP1のセマフォの値を1増やす。
これにより、プロセスP1の待機が解除され、
P1[0]が出力される。
semOther()関数は、引数に1を指定した時0が、0を指定した時1が返ってくる関数である。
これにより、別のプロセスのセマフォを操作することができる。

このように、1.自分のセマフォを1減らす。2.出力を実行する。3.相手のセマフォを1増やす、
という処理を2つのプロセスが繰り返し実行することによって、
交互実行が実現できる。

\subsection{実行結果}
turn.exeを何回か実行した結果を以下に示す。

\begin{screen}
\begin{verbatim}
% ./turn.exe
P0 [ 0 ]
P1 [ 0 ]
P0 [ 1 ]
P1 [ 1 ]
P0 [ 2 ]
P1 [ 2 ]
P0 [ 3 ]
P1 [ 3 ]
P0 [ 4 ]
P1 [ 4 ]
P0 [ 5 ]
P1 [ 5 ]
P0 [ 6 ]
P1 [ 6 ]
P0 [ 7 ]
P1 [ 7 ]
P0 [ 8 ]
P1 [ 8 ]
P0 [ 9 ]
P1 [ 9 ]
\end{verbatim}
\end{screen}
今回は紙面の都合上、
出力する数字の数を10個にした。
何回か実行しても、2つのプロセスが交互に出力していた。
出力する数字の数を増やしても、
正しく実行されることは明らかである。

従って、このプログラムは仕様を満たしている。

\subsection{考察}
交互実行の動作は、
「自分の処理が完了したら、
相手の処理を開始させる」
という処理を繰り返すことで実装することが出来た。
セマフォは複数獲得することができるので、
2つのセマフォを操作することは容易であった。

今回は2つのプロセスの交互実行を実装したが、
操作するセマフォの数を増やせば、
3つ以上のプロセスに順番に処理を行わせることも可能だろう。

発展課題1と3を通して、
セマフォは単純な排他制御を実装するだけではなく、
工夫次第でさまざまな制御に応用することができるということがわかった。




\section{感想・意見}

今回の課題では、
セマフォやパイプ、シグナルハンドラなど、
今まで存在すら知らなかった機能や、
自分で制御できるとは思わなかった機能を使うことによって、
C言語によるプログラミングの奥深さを知ることが出来ました。
ただ、間違ったプログラムを書いてしまった結果、
全てのプロセスを終了させてしまい、
OSをシャットダウンさせてしまうという事態が起こってしまいました。
さまざまな処理を自由に記述することができるようになった反面、
このようなことが起こりうるということも念頭において、
プログラミングを行わなければならないと思いました。

今回の課題は、
課題数は多いものの、
実装自体は簡単なものばかりでした。
その結果、授業時間の半分以上をレポートの記述に費やすことになりました。
レポートの記述がもう少し少なくなるような問題構成だとありがたかったです。

\end{document}