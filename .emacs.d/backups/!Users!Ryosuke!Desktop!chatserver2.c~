#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define TIMEOUT    50
#define STIMEOUT   10
#define MAXCLIENTS 5
#define MAXNAME    20

#define ACCEPTED   "REQUEST ACCEPTED\n"
#define REQREJECT  "REQUEST REJECTED\n"
#define REGISTERED "USERNAME REGISTERED\n"
#define USERREJECT "USERNAME REJECTED\n"

int k = 0;

struct memList {
    int  csock;
    char name[100];
}list[MAXCLIENTS];

int oldPid[MAXCLIENTS];
int sig = 0;

/* 全てのクライアントにメッセージ配信*/
void broadCast(char *str) {

    int i;

    for (i = 0; i < MAXCLIENTS; i ++) {
        if (list[i].csock != -1) {
            write(list[i].csock, str, strlen(str));
        }
    }
}


/* --- s7 離脱処理 -------- */
void sockClose(int i) {

    char str[1024];

    strcat(str, list[i].name);
    strcat(str, " が離脱しました\n");
    broadCast(str);

    printf("%s が離脱しました\n", list[i].name);
    close(list[i].csock);
    list[i].csock = -1;
    strcpy(list[i].name, "\0");
    k--;
}


void myalarm(int clientNum, int fd, int sec) {

    int i, pid, status;

    /* 子プロセスの生成 */
    if ((pid = fork()) == -1) {
        perror("fork failed.");
        exit(1);
    }

    if (pid == 0) { /* 子プロセスの処理 */

        sleep(sec); /* 指定秒待機 */

        /* パイプに書き込み */
        if (kill(getppid(), 0) == 0) {
             if (write(fd, &clientNum, sizeof(clientNum)) == -1) {
                 perror("pipe write.");
                 exit(1);
             }
        }
        exit(0);

    } else {        /* 親プロセスの処理 */
        /* 既存のアラームを削除 */
        if ((oldPid[clientNum] != 0) && (kill(oldPid[clientNum], 0) == 0)) {
            if (kill(oldPid[clientNum], SIGTERM) == -1) {
                perror("kill SIGTERM failed.");
                exit(1);
            }
        }
        /* アラームのPIDを保存 */
        oldPid[clientNum] = pid;

        /* 子プロセスの終了を無視 */
        if(signal(SIGCHLD, SIG_IGN) == SIG_ERR) {
            perror("signal SIGCHLD failed.");
            exit(1);
        }
    }
}

/* 現在時刻の取得  <例> (12:10:30) */
void getTime(char *str) {

    time_t timer;
    struct tm *date;

    timer = time(NULL);
    date  = localtime(&timer);

    strftime(str, 255, "(%H:%M:%S) ", date);
}

/* 参加者一覧を表示 */
void dispMemberList(int i) {

    int j;

    write(list[i].csock, "MEMBERS -> ", 11);
    for ( j = 0; j < MAXCLIENTS; j++) {
        if (list[j].csock != -1) {
            write(list[i].csock, list[j].name, strlen(list[j].name));
            write(list[i].csock, " ", 1);
        }
    }
    write(list[i].csock, "\n", 1);
}

/* ctrl+C の時 フラグを立てる*/
void sigmsg() {
    sig = 1;
}


int main(int argc,char **argv) {


    int sock, cs;
    int clen, reuse, i, j, flag, fd[2];
    struct sockaddr_in svr;
    struct sockaddr_in clt;
    struct hostent *cp;
    char rbuf[1026], un[100], str[1126];
    int nbytes = 1;

    fd_set rfds;       /* select() で用いるファイル記述子集合 */
    struct timeval tv; /* select() が返ってくるまでの待ち時間を指定する変数 */

    /* --- s1 初期状態 -------- */

    /* シグナルハンドラの設定 */
    if(signal(SIGINT,sigmsg) == SIG_ERR) {
        perror("signal failed.");
        exit(1);
    }

    /* リストと変数の初期化 */
    for (i = 0; i < MAXCLIENTS; i++)
        list[i].csock = -1;
    cs = -1;
    k  = 0;

    /* タイムアウト用パイプの生成 */
    if (pipe(fd) == -1) {
        perror("pipe failed.");
        exit(1);
    }

    /* client 受付用ソケットの生成 */
    if ((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))<0) {
        perror("socket");
        exit(1);
    }

    /* ソケットアドレス再利用の指定 */
    reuse=1;
    if(setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,&reuse,sizeof(reuse))<0) {
        perror("setsockopt");
        exit(1);
    }

    /* client 受付用ソケットの情報設定 */
    bzero(&svr,sizeof(svr));
    svr.sin_family=AF_INET;
    svr.sin_addr.s_addr=htonl(INADDR_ANY);
    svr.sin_port=htons(10140);

    /* ソケットにソケットアドレスを割り当てる */
    if(bind(sock,(struct sockaddr *)&svr,sizeof(svr))<0) {
        perror("bind");
        exit(1);
    }

    /* 待ち受けクライアント数の設定 */
    if (listen(sock,MAXCLIENTS) < 0) {
        perror("listen");
        exit(1);
    }

    while(1) {

        /* --- s2 入力待ち -------- */
        FD_ZERO(&rfds);                 /* rfds を空集合に初期化 */
        FD_SET(fd[0], &rfds);           /* タイムアウト用パイプ */
        FD_SET(sock,&rfds);             /* client 受付用ソケット */
        for(i = 0; i < MAXCLIENTS; i++) /* 参加者のソケット */
            if (list[i].csock != -1) FD_SET(list[i].csock, &rfds);

        tv.tv_sec  = 1;
        tv.tv_usec = 0;

        nbytes = 1;
        strcpy(str, "\0");

        /* ソケットとパイプからの受信を同時に監視する */
        if(select(10,&rfds,NULL,NULL,&tv)>0) {

            /*  --- s3 入力処理 -------- */

            for (i = 0; i < MAXCLIENTS; i++) {
                if ((list[i].csock != -1) &&(FD_ISSET(list[i].csock, &rfds))) {

                    /* --- s6 メッセージ配信 -------- */

                    myalarm(i, fd[1], TIMEOUT); /* タイマーの再セット */

                    if ((nbytes = read(list[i].csock, rbuf, sizeof(rbuf))) < 0) {
                        perror("read");

                    } else if (nbytes == 0) {
                        sockClose(i);      /* EOF の時 離脱 */

                    } else if (strncmp(rbuf, "/list\n", 6) == 0){
                        dispMemberList(i); /* /list\n の時 参加者リスト表示 */

                    } else {
                        /* メッセージの配信 */
                        getTime(str); /* 現在時刻を取得 */
                        strcat(str, list[i].name);
                        strcat(str, " > ");
                        strcat(str, rbuf);
                        broadCast(str);
                    }
                }
            }

            if(FD_ISSET(sock,&rfds)) { /* 接続要求があったなら */

                /* --- s4参加受付 -------- */

                clen = sizeof(clt);
                if ((cs = accept(sock,(struct sockaddr *)&clt,&clen)) <0 ) {
                    perror("accept");
                    exit(1);
                }

                if (k >= MAXCLIENTS) {
                    write(cs, REQREJECT, strlen(REQREJECT));
                    close(cs);

                } else {
                    write(cs, ACCEPTED, strlen(ACCEPTED));

                    /* --- s5 ユーザー名登録 -------- */
                    if ((nbytes = read(cs, rbuf, sizeof(rbuf))) < 0) {
                        perror("read");
                    } else {

                        *strstr(rbuf, "\n") = '\0';
                        rbuf[MAXNAME] = '\0';
                        strncpy(un, rbuf, MAXNAME+1);

                        flag = 0;
                        for (i = 0; i < MAXCLIENTS; i++)
                            if (strcmp(un, list[i].name) == 0)
                                flag = 1;

                        if (flag == 1) {
                            printf("同一名がすでに存在します\n");
                            write(cs, USERREJECT, strlen(USERREJECT));
                            close(cs);

                        } else {
                            write(cs, REGISTERED, strlen(REGISTERED));

                            for (i = 0; (i < MAXCLIENTS) && (list[i].csock != -1); i++);
                            list[i].csock = cs;
                            strcpy(list[i].name, un);

                            strcat(str, un);
                            strcat(str, " が参加しました\n");
                            broadCast(str);
                            printf("%s が参加しました\n", un);

                            myalarm(i, fd[1], TIMEOUT); /* アラームのセット */

                            k++;
                        }
                    }
                }
            }

            if(FD_ISSET(fd[0], &rfds)) { /* タイムアウト処理 */
                if (read(fd[0], &i, sizeof(i)) == -1) {
                    perror("pipe read.");
                    exit(1);
                }
                if (list[i].csock != -1) {
                    strcat(str, list[i].name);
                    strcat(str, " がタイムアウトしました\n");
                    broadCast(str);

                    printf("%s がタイムアウトしました\n", list[i].name);
                    write(list[i].csock, "TIMEOUT!\n", 9);
                    sockClose(i);
                }
            }
        }

        /* Ctrl+C が押された時 */
        if (sig == 1) {
            sprintf(str, "%d", STIMEOUT);
            strcat(str, " 秒後にサーバーが終了します\n");
            broadCast(str);
            printf("%d 秒後にサーバーが終了します\n", STIMEOUT);

            sleep(STIMEOUT);

            for ( i = 0; i < MAXCLIENTS; i++) {
                if (list[i].csock != -1) {
                    close(list[i].csock);
                }
            }
            close(sock);

            exit(0);
        }
    }
}
