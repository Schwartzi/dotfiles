package lifegame;

public class Board {

    private int         N, space, hl, maxHist;
    private boolean[][] state, newState;
    LimitedLinkedList   history;

    public Board() {
        
        N       = 30;              //マス目N*N
        space   = 1;               //余白
        hl      = 3;               //HighLifeの時6
        
        //ヒストリの作成
        maxHist = 16;
        history = new LimitedLinkedList(maxHist);
        
        //セルを死に初期化
        state = new boolean[N][N];
        for (int i = 0; i < N ; i++) {
            for (int j = 0; j < N ; j++) {
                state[j][i] = false;
            }
        }
    }
    
    public int getSize() { 
    	
        return N; 
    }
    
    public int getSpace() { 
    	
        return space; 
    }
    
	//isDef = falseの時Hilifeにしてセルを死に初期化
    public void restart(Boolean isDef) {
        
        if (isDef) hl = 3;
            else hl = 6;
    
        for (int i = 0; i < N ; i++) {
            for (int j = 0; j < N ; j++) {
                state[j][i] = false;
            }
        }
        
    }

    // 現在の盤面の状態をもとに，次の世代の盤面の状態に進める．
	public void nextState() {
	    
	    int aliveCell;
	    
	    //ヒストリに追加
	    newState = new boolean[N][N];
	    copyState(newState, state);
	    history.add(state);
	
	    // すべてのセルについて，
	    // 周囲8 セルの生死の状態を調べ，新しい状態を計算する．
	    for (int i = 0; i < N; i++) {
	        for (int j = 0; j < N; j++) {
	            aliveCell = searchAliveCellNum(j, i);
	            if (isAlive(j, i)) {
	                if ((aliveCell <= 1) || (aliveCell >= 4)) 
	                    newState[i][j] = false;
	            } else {
	                if ((aliveCell == 3) || (aliveCell == hl)) 
	                    newState[i][j] = true;
	            }
	        }
	    }
	    
	    state = newState;
	}

	//ヒストリの最後をpop
	public void oldState() {
	    
	    if (history.size() > 0) {       
	        state = history.pollLast();
	    }
	}

	// 盤面の(x, y) で指定されるセルの状態を反転する．
	public void switchLife(int x, int y) {
	    
	    //現在の場面をコピーしてヒストリに保存
	    boolean[][] newState = new boolean[N][N];   
	    copyState(newState, state);
	    history.add(newState);
	    
	    // x, y が盤面の中を指しているときは，セル(x, y) の生死を切り替える．
	    if ((x >= 0) && (y >= 0) && (x < N) && (y < N)) 
	    	state[y][x] = !state[y][x];     
	}

	//指定されたセルの状態を返す。範囲外の場合false
    public boolean isAlive(int x, int y) {
        
        if ((x >= 0) && (y >= 0) && (x < N) && (y < N)) {
            return state[y][x];
        } else {
            return false;
        } 
    }
    
    //周囲8マスの生きているセルの数を返す
    private int searchAliveCellNum(int x, int y) {
    	
        int aliveCell = 0;
        
        for (int i = y - 1; i <= (y + 1); i++) {
            for (int j = x - 1; j <= (x + 1); j++) {
                if (!((i == y) && (j == x))) {
                    if (isAlive(j, i)) aliveCell++;
                }
            }
        }
        return aliveCell;
    }
        
    //2重配列のディープコピー
    private void copyState(boolean[][] cState, boolean[][] state) {
    	
        for (int a = 0; a < N; a++) {
            for (int b = 0; b < N; b++) {
                cState[a][b] = state[a][b];
            }
        }
    }
    
}
