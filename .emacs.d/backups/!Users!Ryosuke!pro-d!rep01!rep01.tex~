\documentclass{icsreport}

\title{プログラミングC 第3回レポート課題} % 題目
\author{谷村亮介}                      % 提出者名
\date{平成24年12月21日}                  % 提出日

\課題名{Javaによるライフゲームの作成}     % 課題名
\担当教官{石尾隆}                       % 担当教官名
\所属{ソフトウェア科学コース}             % 自分の所属するコース名などを指定する. 
\学年{2年}                             % 学年
\学籍番号{09B11044}                    % 学籍番号
                                      % 班やグループ名.
                                      % 必要なければ指定しなくてもよい. 
\email{u549298j@ecs.osaka-u.ac.jp}    % 電子メールのアドレス

\usepackage{ascmac}
\usepackage{here}
\usepackage{txfonts}
\usepackage{listings, jlisting}
\usepackage{color}
\usepackage[dvips]{graphicx}


\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{colFunc}{rgb}{1,0.07,0.54}
\definecolor{CadetBlue}{cmyk}{0.62,0.57,0.23,0}
\definecolor{Brown}{cmyk}{0,0.81,1,0.60}
\definecolor{colID}{rgb}{0.63,0.44,0}
\renewcommand{\lstlistingname}{リスト}
\lstset{language=java,
  basicstyle=\footnotesize\sffamily,
  commentstyle=\textit,
  classoffset=1,
  %keywordstyle=\bfseries,
 % frame=tRBl,
  %framesep=5pt,
  showstringspaces=false,
  numbers=left,
  stepnumber=1,
  numberstyle=\small\sffamily,
  tabsize=2,
  keywordstyle={\bfseries\color{OliveGreen}},
  keywordstyle={[2]\color{colFunc}},
  keywordstyle={[3]\color{CadetBlue}},%
  commentstyle={\color{Brown}},
  %identifierstyle={\color{colID}},
  stringstyle=\color{blue},
}

\begin{document}
\maketitle

\section{課題内容}
プログラミング言語Javaを用いて、「コンウェイのライフゲーム」
を計算機上で実行するためのGUIプログラムを作成する。

\section{プログラムの機能}

\subsection{基本機能}
プログラムに必要な基本機能の仕様を示す。

\begin{description}
  
  \item [盤面の描画]
    プログラムを実行すると、画面に30×30マスのセルが描画される。
    各セルの余白は1ピクセルである。
    ウィンドウのサイズを変えると、それに応じてセルのサイズが変化し、画面いっぱいにセルが描画される。
    縦横どちらかに極端にウインドウを長くしたような場合でも、盤面は画面の中心に描画される。
        
  \item [操作用ボタンの配置]
    ウィンドウ下部に、「Next」と「Undo」の2つのボタンを配置する。
    
  \item [タイトルバーの表示]
    ウィンドウタイトルバーに、「Lifegame-09B11044」と表示する。

  \item [マウスによる盤面の編集] マウスの左ボタンのクリック及び、ドラッグ操作により、
    盤面上のセルの生死状態を切り替える。
    マウスの左ボタンのクリック時と、左ボタンが押された状態でカーソルがセルの境界線を超えて侵入してきた
    時に、セルの生死状態が切り替わる。
    カーソルがセル内部で移動しているときは、セルの生死は切り替えない。
    
  \item [「Next」ボタン押下による世代の更新]
    「Next」ボタンを押すごとに、ライフゲームのルールにしたがって、
    場面の状態を1世代進める。

  \item [「Undo」ボタン押下による操作の巻き戻し]
    「Undo」ボタンを押すごとに、世代を直前の状態に巻き戻す。
    この巻き戻しとは、マウスボタンによって最後に変更されたセルの生死の状態や、
    「Next」ボタンによる世代の変更のことを指す。
    連続で「Undo」ボタンを押した場合には、現在の場面から最大で16操作前までさかのぼることができる。
    なお、ドラッグ操作によって連続して状態を変更した場合でも、
    1つのセルの変化を1つの操作として記録する。
    
\end{description}


\subsection{拡張機能}
以下は、独自に設定した拡張機能の仕様である。

\begin{description}
  
  \item [「Start」ボタンの配置]
    ウィンドウ下部の「Undo」ボタンの右横に、「Start」ボタンを配置する。

  \item [「File」メニューの配置]
    ウィンドウ上部に「File」メニューを配置し、その中に3つのメニューアイテムを作る。
    メニューアイテムの内容は「New」、「Default(23/3)」、「HighLife(23/36)」の3つであり、
    この内、後の2つはどちらか1つを選択でき、初期状態では「Default(23/3)」が選択されている。

  \item [「Color」メニューの配置]
    ウインドウ上部に「Color」メニューを配置し、その中に13のメニューアイテムを作る。
    
  \item [「Start」ボタン押下によるアニメーションのスタート・ストップ]
    「Start」ボタンを押すと、盤面を次の世代へと次々と進めるアニメーションがスタートする。
    フレームレートは10fpsである。
    アニメーション中は、「Next」ボタンと「Undo」ボタンのクリックを禁止する。
    また、マウスによる盤面の変更も禁止する。
    さらにこの時、「Start」ボタンは「Stop」ボタンに切り替わっており、
    これを押すことでアニメーションをストップできる。
    なお、ここでのボタンの切り替わりとは、
    ボタンのラベルの表記が、「Start」から「Stop」に切り替わるということである。
    アニメーションをストップすると、通常と同じ操作ができるようになり、
    「Stop」ボタンは「Start」ボタンに変化する。

  \item [「File」メニューによるモード選択とリスタート]
    Fileメニューにある「HighLife(23/36)」を選択すると、
    死んでいるセルの周囲で生きているセルが3つまたは6つの時にそのセルが誕生するように
    ルールを変更して、ボードを初期化することができる。
    なお、ここでの初期化は、ボードのセルをすべて死にしているだけなので、
    ヒストリは保存されたままである。
    また、「Default(23/3)」を選択すると通常のルールに戻してボードを初期化する。
    「New」をクリックすると、現在の設定のままでボードを初期化する。
    なお、これらのメニューは、アニメーション中にクリックしてもなにも起こらない。

  \item [「Color」メニューによる描画色の切り替え]
    「Color」メニューには、描画色を指定するための13種類のメニューアイテムが存在する。
    そのうち1つのみを選択することができ、選択した色でボードを書き換える。
    アニメーション中も実行可能である。選択可能な色は以下の通り。    
「Black」
「Blue」
「Cyan」   
「DarkGray」
「Gray」 
「Green」  
「LightGray」
「Magenta」
「Orange」     
「Pink」   
「Red」    
「White」
「Yellow」 
    
\end{description}

以上の仕様に沿って作成したライフゲームの、
実際の画面を図\ref{life}に示す。

\begin{figure}[htbp]
  \begin{center}
    \includegraphics[clip,width=8.0cm]{sc.eps}
    \caption{ライフゲームの実行画面}
    \label{life}
  \end{center}
\end{figure}

\section{各機能の実現方法}
プログラムの各機能を実現するために、
「Board」            
「BoardView」        
「ButtonListener」   
「LimitedLinkedList」
「Main」             
「MenuBarListener」
の6つのクラスを作成した。
ここでは、まずライフゲームの実装に必要な「Board」、「BoardView」、「LimitedLinkedList」
クラスについて説明し、
後に、GUIの実装に必要な残りのクラスについて説明する。

%% また、各クラスのメソッドの呼び出し関係の都合により、
%% 説明の順序を入れ替える場合がある。
%% たとえば、AクラスのメソッドをBクラスで使用する場合、
%% その説明をBクラスのセクションで説明することがある。

\subsection{BoardView}
このクラスは、GUIボタンからの入力に応じて、
セルの状態を変化させ、
現在のセルの状態に応じて、盤面を再描画するためのクラスである。

まず、コンストラクタについて説明する。
ここでは、
セルの状態を保持するBoardオブジェクトを生成し、
盤面の描画色を初期化する。
この時、描画色は黒である。
次に、Boardオブジェクトに保持されている盤面のサイズと、
余白を取り出してフィールドに保管しておく。
最後に、マウスクリックとドラッグに対応するアクションリスナーを登録している。

Paintメソッドは、現在のセルの状態と描画領域のサイズに応じて、
盤面を描画するメソッドである。
まず、描画領域の幅と高さを取得する。
幅と高さの短い方の値から、
個数に応じた余白分を引いた値が、
セルを描画可能なピクセル数になるから、
それをセルの個数で割った商が、セルのサイズになる。

次に、ウィンドウを縦か横に極端に長くした場合でも、
盤面が中央に表示させるように、
描画の初期位置を計算する。
これは、盤面を描画しても余った余白の部分の長さの半分の地点から、
描画を開始することで実現できる。
例えば、横の長さが200で、盤面のサイズが100の時、
$(200-100) / 2 = 50$の地点で描画をはじめることにより、
盤面を中央に描画できる。

次に、2重配列を用いて盤面を描画していく、
BoardクラスのisAliveメソッドを用いると、
セルの生死の状態がわかるので、
セルが生きている場合は、fillRectを用いて四角形を塗りつぶし、
死んでいる場合はdrawRectを用いて塗りつぶし無しの四角形を描画する。


searchXとsearchYメソッドは、ウィンドウのピクセル座標から、
その座標位置がどのセルに属しているかを計算するプライベートメソッドである。
この2つのメソッドは構造上は同じなので、ここではsearchXメソッドについて説明する。
まず、指定された座標位置が盤面の描画開始位置より小さい場合は、
どのセルも指していないことを示すN+1を返す。
次に、セル位置の計算を開始していく。
ここでは、セルのサイズと余白を順次足していき、
ピクセル座標の当てはまる位置を割り出している。
例えば、xがsize+spaceよりも大きく、size+space+sizeよりも小さい場合には、
そのピクセル位置は、左から2番めのセルに該当することになる。
また、sizeよりも大きく、size+spaceよりも小さい場合は、
そのピクセル位置は、余白部分を指していることがわかるから、N+1を返す。
また、盤面の右外を指している場合も、N+1を返す。
セル以外の部分を指している時には一律してN+1を返すことにより、
このあとの処理が容易になる。




mousePressedメソッドは、マウスがクリックされた時に呼び出されるメソッドである。
まず、startStopの状態で条件分岐しているが、
これは、アニメーション中はマウスによる盤面の変更を禁止するためである。
アニメーション中でない時には、
マウスの座標を取得して、
searchXとsearchYメソッドを利用して、その座標に対応するセルの座標を計算し、
BoardクラスのswitchLifeを用いてセルの状態を反転させる。
また、oldXとoldYというフィールド変数が用意されていて、
これに以前変更したセルの座標を保管しておく。
ここでは、swichLifeの実行と同時に、変更したセルの座標をoldXなどに保存している。
最後に、repaintで盤面を再描画する。

mouseDraggedメソッドは、マウスがドラッグされた時に呼び出されるメソッドである。
mousePressedメソッドと同じく、アニメーション中は何もしないようになっている。
まず、oldXとoldYの値を参照して、ドラッグで現在指している部分が、
先に変更したのと同じセルを指しているかどうかを判定する。
これにより、同じセルの中を移動した際に、何度もセルの状態が変更されるのを防いでいる。
先ほど変更したのと別のセルを指した際には、swichLifeを実行し、
セルの状態を変化させる。

ここで重要なのが、セル以外の部分をクリックしたりドラッグした際には、
N+1番目のセルの状態を切り替えたことになるという事である。
これにより、一度盤面の外を経由して同じセルをドラッグした際に、
きちんとセルの状態を変化させることができる。


最後に、拡張機能であるアニメーションの実行について説明する。
アニメーションを実行するには、一定の間隔でnextStateが実行されるようにすれば良い。
そのために、このクラスにRunnableインターフェイスを実装した。
また、現在のアニメーションの開始、停止状態を管理するため、
Boolean型の変数 startStopを用意した。
ウィンドウ上のStartボタンをクリックすると、startAnimationが実行される。
アニメーション停止中はstartStopにtrueがセットされ、
新たなスレッドが生成される。
ここで、startメソッドを実行すると、
自動的にrunメソッドが実行される。
すると、100ミリ秒の間隔をはさみながら、
nextStateが実行される。
この状態でstartStopの値がfalseにセットされると、
アニメーションが終了する。


\subsection{LimitedLinkedList}
「Undo」ボタンによる機能を実装するために、
LinkedListクラスを用いて盤面の状態を保管しておくことにした。
仕様では、履歴の保存数は最大16個となっているので、
これを継承して、保存できる履歴の数に制限をかけられる、
LimitedLinkedLisdを作成した。

このクラスは、要素に保存できるデータに制限をつけるために、
\verb+LinkedList<boolean[][]>+を継承している。
コンストラクタは引数を1つ持ち、
これが格納できるデータの最大数となる。
histnumには現在のデータ数を保管する。

データの挿入のために、
addメソッドをオーバーライドして使用した。
このメソッドはリストの最後にデータを挿入するものである。
データ数がmaxHist以下の場合には、
スーパークラスのaddを用いてデータを挿入する。
このメソッドを呼び出すたびに、
histnumの値を加算していき、
もし、maxHistの値を超えた場合は、
removeメソッドで先頭のデータを除去したあと、
新たなデータを挿入する。

データの取り出しのために、
pollLastメソッドをオーバーライドして使用した。
このメソッドは、リストの最後のデータを返してそれを削除するものである。
histnumの値を1つ減らしたあとスーパークラスのpollLastを用いてデータを取り出す。

データの登録数を制限したリストのクラスを用意しておくことで、
リストを使用する側のクラスの記述を簡単にすることができる。

\subsection{Board}
Boardクラスは、セルの状態を保持し、
BoardViewクラスからの操作に応じて、盤面の状態を更新、復元するものである。

まず、コンストラクタについて説明する。
ここではマス目と余白を初期化している。
変数hlについては拡張機能で使用するため、
説明は後述する。
次に、ヒストリを作成する。
仕様では、ヒストリの最大数は16であるため、
コンストラクタの引数には16を与える。
最後に、N行N列のBoolean型の配列を作って、
すべてをFalseにしておく。
これがセルの状態を表す。

nextStateメソッドは、
盤面を次の世代に更新するためのメソッドである。
まず、新しい盤面を保存するための配列を作成しておき、
copyStateメソッドで現在の状態をコピーする。
copyStateメソッドは、2重配列をディープコピーするためのプライベートメソッドであり、
このクラスの最後で記述してある。
このあと、現在の盤面の状態をヒストリに加えておく。
ここからは、
すべてのセルについて、周囲8セルの生死の状態を調べ、新しい状態を計算する。
searchAliveCellNumメソッドはあるセルに対して、
周囲8セルの生きているセルの数を返すプライベートメソッドである。
周囲8セルに対してisAliveを実行し、trueが返ってきた回数を数える。
これを実行したあと、現在見ているセルの状態に応じて、処理をおこなう。
生きているセルの周囲で生きているセルが1以下4以上の場合はそのセルは死に、
死んでいるセルの周囲で生きているセルが3の場合はそのセルは誕生する。
すべてのセルの処理が終了したら、stateが新しい盤面の状態を参照する。
これで、新しい状態への更新が完了する。

oldStateメソッドは前の盤面の状態を復元するためのメソッドである。
ヒストリにデータが保管されている時は、
pollLastメソッドで前の状態をpopして、それを参照する。

swichLifeメソッドは、盤面の(x,y)座標で指定されたセルの状態を反転するメソッドである。
マウス操作によって呼び出される。
まず、nextStateメソッドと同様にして、現在の盤面の状態をヒストリに保存しておく。
そして、引数の値が有効ならば、セルの状態を反転させる。
マウスが盤面以外の部分を選択した際は、引数としてN+1が与えられるが、
ここの判定によって、それに対する処理は実行されないようになっている。

isAliveメソッドは、指定されたセルの状態を返すメソッドである。
引数が有効な場合はそのセルの状態を返し、
範囲外の場合はfalseを返す。
配列の定義外の部分を参照しようとするとエラーが出るため、
引数にどんな値が与えられても対応できるようにしておくことは重要である。

\subsection{Main}

Mainクラスでは、ウィンドウのパーツ配置を行なっている。

まず、ウィンドウとベースバネルを作成して、
ウィンドウのタイトルを「Lifegame09B11044」に設定する。
次に、BoardView型のオブジェクトを生成して、
ベースバネルの中心に配置する。

次に、ボタンを配置していく。
まず、ボタン用パネルを作成し、ベースバネルの下端に配置する。
そして、Next、Undo、Startの各ボタンを生成して配置する。
これらのボタンをクリックした際の設定は、
ButtonListenerクラスで設定しているので、
各ボタンのアクションリスナーを追加していく。


最後に、メニューバーを配置する。
メニューバーのメニューに、
FileとColorを配置する。
Fileメニュー内のメニューアイテムは、
New、Default(23/3)、HighLife(23/36)の3つである。
この内、後者2つはどちらか一方のみを選択できるようにするため、
ラジオボタンとして生成し、1つのグループにまとめている。
最初はDefault(23/3)が選択されているようにする。
メニューアイテムをクリックした際の設定は、
MenuBarListenerクラスで設定してあるので、
各アイテムのアクションリスナーを追加していく。
Colorメニューには、描画色の設定に対応する13個のラジオボタンを配置する。
Blackボタンを例にとって説明する。
まず、Blackというラベルの付いたラジオボタンを生成し、
文字色を黒にする。
グループに追加して、Colorメニューに追加する。
そして、アクションリスナーを追加する。
デフォルトの描画色は黒なので、
最初にこのボタンが選択されているようにする。
この操作を他の12個のボタンでも繰り返す。

すべての要素を配置し終えたら、
packしてウィンドウを表示する。


\subsection{ButtonListener}

このクラスは、Next、Undo、Startの各ボタンの動作を設定するものである。
ActionListenerインターフェイスを実装する。
まず、コンストラクタで、各ボタンと盤面への参照をコピーしておく、
このクラスでこれらのパーツを制御できるようにするためである。

それぞれのボタンをクリックすると、actionPerformedが実行される。
getSourceをすることで、どのボタンが押されたか判定することができる。

Nextボタンが押された場合は、BoardViewのnextStateが実行される。
すると、このnextStateはBoardのnextStateを呼び出して、
盤面が次の世代に更新される。
そして、repaintで盤面を再描画することで、Nextボタンの挙動が実現される。

Undoボタンが押された場合は、BoardViewのoldStateが実行される。
すると、このoldStateはBoardのoldStateを呼び出して、
盤面の状態が復元される。
そして、repaintで再描画することで、Undoボタンの挙動が実現される。

Startボタンが押された場合は、現在の状態に応じて
アニメーションをスタート、ストップする。
まず、現在のアニメーションの状態を管理するために、
BoardViewと同様に、startStopというBoolean型の変数を作成しておく。
初めはこれにfalseが設定されていて、アニメーションは止まっている状態となる。
Startボタンが押されると、
BoardViewのstartStopの値を反転させて、
その値に応じて処理を分岐する。
startStopがtrueの場合は、
これからアニメーションを開始することになるので、
StartボタンのラベルをStopに置き換え、
Next、Undoボタンをクリックできないようにする。
そして、startAnimation(true)を実行して、アニメーションを実行する。
falseの場合は、これからアニメーションを停止することになるので、
StopボタンのラベルをStartに置き換え、
Next、Undoボタンをクリックできないようにする。
そして、startAnimation(false)を実行して、アニメーションを停止する。


\subsection{MenuBarListener}

このクラスは、メニューバーのアイテムをクリックした際の動作を設定するものである。
ActionListenerインターフェイスを実装する。
まず、コンストラクタで、盤面とDefault(23/3)ボタンへの参照をコピーしておく。

それぞれのボタンをクリックすると、actionPerformedが実行される。
getActionCommandを実行することで、押されたボタンのラベルを取得することができる。

押されたボタンがFileメニュー内のものであり、
アニメーション中でない場合には、
Defaultボタンが選択されているかどうかの情報を取得して、
BoardView型のrestartを実行する。
このrestartはBoard型のrestartを実行する。
Board型のrestartには、Defaultボタンの選択状態が引数として与えられる。
選択されているときは、変数hlの値が3になり、
選択されていないとき、すなわちHighLifeボタンが選択されているときは、
hlの値を6にする。
そして、セルの状態をすべて死にする。
BoardのnextStateメソッドには、
\verb+if ((aliveCell == 3) || (aliveCell == hl)) newState[i][j] = true;+
という行がある。
hlが3の時には基本ルールと変わらないが、
hlが6の時には、セルの周囲で生きているセルの個数が3か6の時に、そのセルが誕生するようになる。

押されたボタンがColorメニュー内のものである場合は、
どのボタンが押されたかを判定して、setPointColorで盤面の描画色を設定する。


\section{考察}

\subsection{プログラムの良い点}
まず、プログラムの良い点として、
要求された仕様に対して自分なりに工夫した点などについて考察する。

\begin{itemize}
  \item 盤面を描画する際に、画面の縦横のどちらかが極端に長い場合でも、
    中心に描画できるように計算した。
    GUIアプリケーションでは、ユーザーがウィンドウのサイズを自由に変更することができる。
    ウィンドウがどのような形になっても描画が崩れないように工夫することが、
    GUIアプリケーションのプログラミングにおいて重要であると感じた。

  \item セッター、ゲッターを自分でもいくつか定義して使用した。
    これらを効果的に用いることで、異なるクラス間のデータの受け渡しを、
    円滑かつ確実に行うことができるようになったことを実感できた。

  \item ヒストリの保存を行うために、LinkedListを継承した新たなクラスを作成することで、
    簡単に、仕様を満たすヒストリを作成することができた。
    例えばC言語で連結リストを実装しようと思えば、一からたくさんの記述を行わなければならないが、
    Javaでは予め用意されているクラスをインスタンス化することですぐに利用することができるし、
    オーバーライドなどを利用することで、仕様に適合したリストに改造することも容易である。
    今回のヒストリの実装によって、以上のようなオブジェクト指向プログラミングの恩恵を実感することができた。
    ただ、ライブラリをインポートすることで様々な機能を実装することができる反面、
    クラスの使用方法に戸惑うことが多かった。
    Eclipseの機能やウェブ検索などを利用して、
    使用するクラスのコンストラクタの使用法や、
    どのようなメソッドを持っていて、どのように引数を与えれば良いのかといった情報を、
    しっかりと把握しておくことが重要であると感じた。
    
  \item アニメーションの実行中は、マウスによる盤面の変更や、
    ボタンによる世代の更新ができないようにした。
    これにより、アニメーション中にデータの整合性が失われてしまうことを防ぐことができた。
    GUIアプリケーションでは、入力の自由度がCUIアプリケーションよりも増しているため、
    あらゆる可能性を考慮して、入力に適切な制限を加えておくことが重要である。

  \item
    アニメーションを再生・停止するたびに「Start」ボタンと「Stop」ボタンのラベルが切り替わる
    ようにした。
    この演出は、多くの動画再生ソフトで実際に使用されているのを参考にして考えたものである。
    GUIアプリケーションでは、ユーザーの操作のしやすさを考えながらプログラミングをすることも、
    重要な要素の1つである。

\end{itemize}


\subsection{プログラムの悪い点}

次に、プログラムの悪い点、すなわち、もっと改善可能だと思われる点について考察する。

\begin{itemize}
  
   \item マウスのxy座標から盤面のXY座標に変換する際に、実装のしやすさを優先したため、
     あまり効率的ではないアルゴリズムになってしまっている。
     この変換作業は、マウスのドラッグ時には頻繁に行う作業であり、
     計算量によってはプログラムの動作が遅くなってしまう可能性もある。
     今回は明らかな遅延は認められなかったのでこのままでよいはずであるが、
     頻繁に行う作業において、少しでも早い実行速度が求められる場合には、
     はじめから、効率の良い方法をじっくりと検討して実装を行うべきである。
     例えば、今回の場合は、授業でも紹介があったように、
     マウスの座標と盤面の座標の対応関係の情報を配列などに保管しておくという方法が考えられる。

   \item Fileメニュー内のボタンを押すことで盤面の状態をリセットできるようになっているが、
     これは、配列の値をすべてfalseにしているだけなので、ヒストリの内容はリセットされていない。
     今回は拡張機能として実装したため、これでも構わないが、
     仕様によっては、この方法はリセットに該当しない場合もある。
     現在の盤面の状態を保持しているBoardViewクラスのオブジェクトを削除して再生成することで、
     本当のリセット機能を実現できると考えられる。
     今回の課題ではその方法で実装することができなかったが、
     状態のリセットというのは色々なプログラムで実装する必要が出てくると思うので、
     今後はきちんと実装できるようにしておきたい。

   \item Mainクラス内のGUIパーツの配置に関する記述が、冗長になってしまった。
     例えば、Colorメニュー内のメニューアイテムについては、1つのアイテムに対して5行の記述が必要で、
     それが13個分必要になっている。
     必要最低限の記述をしているだけなので仕方のない面もあるが、
     コメントをこまめに入れるなどして、
     読みやすく、拡張のしやすいコードにしておくことも必要であると感じた。
     
\end{itemize}
     

    
      


\end{document}
