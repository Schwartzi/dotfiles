--
--  File        : alu.vhd
--  Author      : Masaharu Imai
--  Date        : 2010/12/25
--  Version     : 1.0
--  Abstract    : Very Small Alu with Flags
--
--  Modification History:
--  Date        By  Version Change Description
--  ==================================================================
--  2010/12/25  MI  1.0     Original
--  ==================================================================
--

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use work.alu_pack.all;

entity alu is
    generic (
        N_BIT:  natural := 8 );
    port (
        sel_in: in  std_logic_vector( 2       downto 0);
        a_in:   in  std_logic_vector( N_BIT-1 downto 0 );
        b_in:   in  std_logic_vector( N_BIT-1 downto 0 );
        c_in:   in  std_logic;
        d_out:  out std_logic_vector( N_BIT-1 downto 0 );
        c_out:  out std_logic;
        z_out:  out std_logic;
        s_out:  out std_logic;
        v_out:  out std_logic;
        p_out:  out std_logic );

end entity alu;

----------------------------------------------------------------------
--  Behavior Model
----------------------------------------------------------------------

architecture behavior of alu is
begin
    process( sel_in, a_in, b_in, c_in )
        constant MINUS_ONE:  std_logic_vector( N_BIT-1 downto 0 ) :=
                        ( others => '1' );
        variable a_tmp: std_logic_vector( N_BIT downto 0 );
        variable b_tmp: std_logic_vector( N_BIT downto 0 );
        variable not_b: std_logic_vector( N_BIT downto 0 );
        variable d_tmp: std_logic_vector( N_BIT downto 0 );
        variable z_tmp: std_logic;
        variable v_tmp: std_logic_vector( N_BIT-1 downto 0 );
        variable p_tmp: std_logic;
    begin
    
        a_tmp := '0' & a_in;
        b_tmp := '0' & b_in;
        not_b := '0' & not b_in;
        
        case sel_in is
        
            when "000"  =>  d_tmp := a_tmp + c_in;
                            v_tmp := ( '0' & a_in( N_BIT-2 downto 0 ) ) +
                                     c_in;
                            v_out <= d_tmp( N_BIT ) xor v_tmp( N_BIT-1 );
                            
            when "001"  =>  d_tmp := a_tmp + b_tmp + c_in;
                            v_tmp := ( '0' & a_in( N_BIT-2 downto 0 ) ) +
                                     ( '0' & b_in( N_BIT-2 downto 0 ) ) + 
                                     c_in;
                            v_out <= d_tmp( N_BIT ) xor v_tmp( N_BIT-1 );

                            
            when "010"  =>  d_tmp := a_tmp + not_b + c_in;
                            v_tmp := ( '0' & a_in( N_BIT-2 downto 0 ) ) +
                                     ( '0' & not b_in( N_BIT-2 downto 0 ) ) +
                                     c_in;
                            v_out <= d_tmp( N_BIT ) xor v_tmp( N_BIT-1 );


            when "011"  =>  d_tmp := a_tmp + MINUS_ONE + c_in;
                            v_tmp := ( '0' & a_in( N_BIT-2 downto 0 ) ) +
                                     ( '0' & MINUS_ONE( N_BIT-2 downto 0 ) ) +
                                     c_in;
                            v_out <= d_tmp( N_BIT ) xor v_tmp( N_BIT-1 );

                            
            when "100"  =>  d_tmp := a_tmp or  b_tmp;
                            d_tmp( N_BIT ) := '0';
                            v_out <= '0';
                            
            when "101"  =>  d_tmp := a_tmp xor b_tmp;
                            d_tmp( N_BIT ) := '0';
                            v_out <= '0';

            when "110"  =>  d_tmp := a_tmp and b_tmp;
                            d_tmp( N_BIT ) := '0';
                            v_out <= '0';

            when "111"  =>  d_tmp := not a_tmp;
                            d_tmp( N_BIT ) := '0';
                            v_out <= '0';

            when others =>  d_tmp := ( others => 'X' );
                            v_out <= 'X';
            
        end case;
        
        d_out <= d_tmp( N_BIT-1 downto 0 );

        c_out <= d_tmp( N_BIT );
        
        z_out <= vnor( d_tmp( N_BIT-1 downto 0 ) );

        s_out <= d_tmp( N_BIT-1 );
        
        p_out <= vxor( d_tmp( N_BIT-1 downto 0 ) );

    end process;
    
end architecture behavior;


----------------------------------------------------------------------
--  Begin Structure Model 作成部分始まり
----------------------------------------------------------------------


architecture structure of alu is
  component full_adder is
    port (
      a_in  : in  std_logic;
      b_in  : in  std_logic;
      c_in  : in  std_logic;
      c_out : out std_logic;
      s_out : out std_logic);
  end component full_adder;

  signal or_op   : std_logic;
  signal and_op  : std_logic;
  signal sel_or  : std_logic_vector(N_BIT-1 downto 0);
  signal sel_and : std_logic_vector(N_BIT-1 downto 0);
  
  signal sel_p2 : std_logic_vector(N_BIT-1 downto 0);
  signal sel_p1 : std_logic_vector(N_BIT-1 downto 0);
  signal sel_p0 : std_logic_vector(N_BIT-1 downto 0);

  signal a_tmp  : std_logic_vector(N_BIT-1 downto 0);
  signal b_tmp  : std_logic_vector(N_BIT-1 downto 0);
  signal ci_tmp : std_logic_vector(N_BIT-1 downto 0);
  signal co_tmp : std_logic_vector(N_BIT-1 downto 0);

  signal d_tmp  : std_logic_vector(N_BIT-1 downto 0);
  
begin  -- structure

  --"100" for OR operation
  or_op   <= sel_in(2) and (not sel_in(1)) and (not sel_in(0));

  --"110" for AND operation
  and_op  <= sel_in(2) and sel_in(1) and (not sel_in(0));

  sel_or  <= (others => or_op);
  sel_and <= (others => and_op);

  sel_p2 <= (others => sel_in(2));
  sel_p1 <= (others => sel_in(1));
  sel_p0 <= (others => sel_in(0));

  a_tmp  <= a_in or (sel_or and b_in) or (sel_and and (not b_in));
  b_tmp  <= (sel_p0 and b_in) or (sel_p1 and (not b_in));
  ci_tmp <= (not sel_p2) and (co_tmp(N_BIT-2 downto 0) & c_in);
  
  
  FADD_ARRAY: for i in 0 to N_BIT-1 generate
    FADD_X : full_adder port map (
      a_in   => a_tmp(i),
      b_in   => b_tmp(i),
      c_in   => ci_tmp(i),
      s_out  => d_tmp(i),
      c_out  => co_tmp(i));
  end generate;

  d_out  <= d_tmp(N_BIT-1 downto 0);

  c_out  <= (not sel_in(2)) and co_tmp(N_BIT-1);

  z_out  <= vnor(d_tmp(N_BIT-1 downto 0));

  s_out  <= d_tmp(N_BIT-1);

  v_out  <= (not sel_in(2)) and ((co_tmp(N_BIT-1) xor (co_tmp(N_BIT-2))));

  p_out  <= vxor(d_tmp(N_BIT-1 downto 0));


end architecture structure;


----------------------------------------------------------------------
--  End Structure Model 作成部分終わり
----------------------------------------------------------------------
