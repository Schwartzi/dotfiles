#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/sem.h>

#define NUMPROCS 2

/* セマフォ操作関数 */
void mySemop(int sid, int num, int op) {

    struct sembuf sb;

    sb.sem_num = num;
    sb.sem_op  = op;
    sb.sem_flg = 0;

    if (semop(sid, &sb, 1) == -1) {
        perror("mySemop ");
        exit(1);
    }
}

int semOther(int sem) {

    if        (sem == 0) {
        return  1;
    } else if (sem == 1) {
        return  0;
    } else {
        return -1;
    }
}


main() {

    int   i, j, pid, sid, status;
    key_t key;
    struct sembuf sb;

    setbuf(stdout, NULL);      /* set stdout to be unbufferd */

    /* セマフォの作成 */
    key = ftok("semaphore", 1);
    if ((sid = semget(key, 2, 0666 | IPC_CREAT)) == -1) {
        perror("semget error.");
        exit(2);
    }

    semctl(sid, 0, SETVAL, 1); /* プロセス0 のセマフォの値を 1 に */
    semctl(sid, 1, SETVAL, 0); /* プロセス1 のセマフォの値を 0 に */

    /* 子プロセス生成と実行 */
    for (i = 0; i < NUMPROCS; i++) {

        if ((pid = fork()) == -1) {
            perror("fork failed.");
            exit(3);
        }
        if (pid == 0) { /* Child process */
            /* 交互実行処理 */
            for (j = 0; j < 10; j++) {
                mySemop(sid, i, -1);          /* WAIT */
                printf("P%d [ %d ]\n", i, j); /* CS */
                mySemop(sid, semOther(i), 1); /* SIGNAL */
            };
            exit(0);
        }
    }

    for (i = 0; i < NUMPROCS; i++) {
        wait(&status);
    }

    /* セマフォを削除 */
    if (semctl(sid, 0, IPC_RMID, 0) == -1) {
        perror("sem clear");
        exit(EXIT_FAILURE);
    }
}
