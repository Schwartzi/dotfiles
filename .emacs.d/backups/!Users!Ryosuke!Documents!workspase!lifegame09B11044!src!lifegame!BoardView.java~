package lifegame;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;


import javax.swing.JPanel;

@SuppressWarnings("serial")
public class BoardView extends JPanel
	implements MouseListener, MouseMotionListener, Runnable{

	private Board   state;
	private int     N, space, size, startX, startY, oldX, oldY;
	private Thread  t1;
	private Boolean startStop = false;
	private Color   paintColor;
		
	public BoardView(){
		
		this.state = new Board();
		paintColor = new Color(0, 0, 0);	//Color.black
		N          = state.getSize();
		space      = state.getSpace();
		
		this.addMouseListener(this);
		this.addMouseMotionListener(this);
	}
	
	//Color.XXで描画色をset
	public void setPaintColor(Color pc) {
		
		paintColor = pc;
		this.repaint();
	}
	
	//アニメーションの状態を返す
	public boolean getStartStop() {
		return startStop;
	}
	
	@Override
	synchronized public void paint(Graphics g) {
		
		//セルのサイズの計算
		int w = this.getWidth()  - 1;
		int h = this.getHeight() - 1;
		size =(Math.min(w, h) - (N - 1) * space) / N;
		
		//xy座標の初期位置を計算
		startX = (w - ((size + space) * N)) / 2;
		startY = (h - ((size + space) * N)) / 2;
		
		super.paint(g); 		//背景塗りつぶし
		
		g.setColor(paintColor);	//描画色のセット
		
		//セルの描画
		int x= startX, y = startY;
		for (int i = 0; i < N; i++) {
			x = startX;
			for (int j = 0; j < N; j ++) {
				if (state.isAlive(j, i)) {
					g.fillRect(x, y, size, size);			
				} else {
					g.drawRect(x, y, size - 1, size - 1);
				}
				x += size + space;
			}
			y += size + space;  
		}
	}
	
	//マウスのx座標からセルのX座標を割り出す
	private int searchX(int x) {
		
		int j = startX;
		
		if (x < startX) return N + 1;
		for (int i = 0; i < N ; i++ ) {
			if (x <= (j += size)) {
				return i;
			} else if (x <= (j += space))  {
				return N + 1;
			}
		}
		return N + 1;
	}
	
	//マウスのy座標からセルのY座標を割り出す
	private int searchY(int y) {
		
		int j = startY;
		
		if (y < startY) return N + 1;
		for (int i = 0; i < N ; i++ ) {
			if (y <= (j += size)) {
				return i;
			} else if (y <= (j += space))  {
				return N + 1;
			}
		}
		return N + 1;
		
	}
	
	public void restart(Boolean isDef) {
		
		state.restart(isDef);
		this.repaint();
	}

	synchronized public void nextState() {
		
		state.nextState();
		this.repaint();
	}
	
	synchronized public void oldState() {
		
		state.oldState();
		this.repaint();
	}

	public void startAnimation(Boolean st) {
		
		startStop = st;
		t1  = new Thread(this) ;
		t1.start();
	}

	@Override
	public void run() {
		try {
			while(startStop) {
				this.nextState();
				Thread.sleep(100);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	synchronized public void mousePressed(MouseEvent e) {
		
		if (!startStop) {
			state.switchLife(oldX = searchX(e.getX()), oldY = searchY(e.getY()));
			this.repaint();
		}
	}

	synchronized public void mouseDragged(MouseEvent e) {
		
		if(!startStop) {
			if ((searchX(e.getX()) != oldX) || (searchY(e.getY()) != oldY)) {
				state.switchLife(oldX = searchX(e.getX()), oldY = searchY(e.getY()));
				this.repaint();	
			}	
		}
	}

	public void mouseEntered(MouseEvent e) {}
	public void mouseExited(MouseEvent e) {}
	public void mouseReleased(MouseEvent e) {}
	public void mouseMoved(MouseEvent e) {}
	public void mouseClicked(MouseEvent e) {}
	
}
