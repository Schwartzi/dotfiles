#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

#define TIMEOUT 10

int timeoutFlag = 0;

void myalarm(int sec) {

    static int oldPid;
    int i, pid, status;

    if ((pid = fork()) == -1) {
        perror("fork failed.");
        exit(1);
    }

    if (pid == 0) { /* Child process */

        sleep(sec);

        /* 親プロセスにSIGALRMを送信 */
        if (kill(getppid(), SIGALRM) == -1) {
            perror("kill Parent failed.");
            exit(1);
        }
    // oldPid = 0;
        exit(0);

    } else {        /* Parent process */

        /* 既存のアラームを削除 */
        if (oldPid != 0) {
            if (kill(oldPid, SIGTERM) == -1) {
                perror("kill oldAlarm failed.");
                exit(1);
            }
        }
        /* アラームのPIDを保存 */
        oldPid = pid;

        /* 子プロセスの終了を無視 */
        if(signal(SIGCHLD, SIG_IGN) == SIG_ERR) {
            perror("signal SIGCHLD failed.");
            exit(1);
        }
    }
}

void timeout() {
    timeoutFlag = 1;
}

int main(int argc,char **argv) {

    int    sock;
    struct sockaddr_in host;
    struct hostent     *hp;

    char   rbuf[1024];
    int    nbytes = 1;

    fd_set rfds;       /* select() で用いるファイル記述子集合 */
    struct timeval tv; /* select() が返ってくるまでの待ち時間を指定する変数 */

    /* シグナルハンドラを設定 */
    if(signal(SIGALRM,timeout) == SIG_ERR) {
        perror("signal failed.");
        exit(1);
    }

    /* ソケットの生成 */
    if ((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))<0) {
        perror("socket");
        exit(1);
    }

    /* host(ソケットの接続先) の情報設定 */
    bzero(&host,sizeof(host));
    host.sin_family=AF_INET;
    host.sin_addr.s_addr=htonl(INADDR_ANY);
    host.sin_port=htons(10130);

    /* IPアドレスの取得 */
    if ( ( hp = gethostbyname(argv[1]) ) == NULL ) {
        fprintf(stderr,"unknown host %s\n",argv[1]);
        exit(2);
    }
    bcopy(hp->h_addr,&host.sin_addr,hp->h_length);

    /* ホストに接続 */
    if (connect(sock, (struct sockaddr*)&host, sizeof(host)) < 0) {
        perror("connect");
        exit(3);
    } else {
        printf("Connected to [%s]\n", hp->h_name);
    }

    /* タイマーを設定 */
    myalarm(TIMEOUT);

    do{
        /* 入力を監視するファイル記述子の集合を変数 rfds にセットする */
        FD_ZERO(&rfds);     /* rfds を空集合に初期化 */
        FD_SET(0,&rfds);    /* 標準入力 */
        FD_SET(sock,&rfds); /* 作成したソケット */

        /* 監視する待ち時間を 1 秒に設定 */
        tv.tv_sec  = 1;
        tv.tv_usec = 0;

        /* 標準入力とソケットからの受信を同時に監視する */
        if(select(sock+1,&rfds,NULL,NULL,&tv)>0) {

            /* タイマーを再設定 */
            myalarm(TIMEOUT);

            if(FD_ISSET(0,&rfds)) { /* 標準入力から入力があったなら */
                /* 標準入力から読み込みサーバーに送信 */
                if ((nbytes = read(0, rbuf, sizeof(rbuf))) < 0) {
                    perror("send");
                } else {
                    write(1, "client ", 7);
                    write(1, rbuf, nbytes);
                    write(sock, rbuf, nbytes);
                }
            }

            if(FD_ISSET(sock,&rfds)) { /* ソケットから受信したなら */
                /* ソケットから読み込み端末に出力 */
                if ((nbytes = read(sock, rbuf, sizeof(rbuf))) < 0) {
                    perror("read");
                } else {
                    write(1, hp->h_name, strlen(hp->h_name));
                    write(1, rbuf, nbytes);
                }
            }
        }

        /* タイムアウト処理 */
        if(timeoutFlag == 1) {
            printf("TimeOut!\n");
            write(sock, "", 0);
            close(sock);
            exit(0);
        }

    } while (nbytes != 0);

    close(sock);
    printf("closed\n");

}
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

#define TIMEOUT 10

int timeoutFlag = 0;

void myalarm(int sec) {

    static int oldPid;
    int i, pid, status;

    if ((pid = fork()) == -1) {
        perror("fork failed.");
        exit(1);
    }

    if (pid == 0) { /* Child process */

        sleep(sec);

        /* 親プロセスにSIGALRMを送信 */
        if (kill(getppid(), SIGALRM) == -1) {
            perror("kill Parent failed.");
            exit(1);
        }
    // oldPid = 0;
        exit(0);

    } else {        /* Parent process */

        /* 既存のアラームを削除 */
        if (oldPid != 0) {
            if (kill(oldPid, SIGTERM) == -1) {
                perror("kill oldAlarm failed.");
                exit(1);
            }
        }
        /* アラームのPIDを保存 */
        oldPid = pid;

        /* 子プロセスの終了を無視 */
        if(signal(SIGCHLD, SIG_IGN) == SIG_ERR) {
            perror("signal SIGCHLD failed.");
            exit(1);
        }
    }
}

void timeout() {
    timeoutFlag = 1;
}

int main(int argc,char **argv) {

    int    sock;
    struct sockaddr_in host;
    struct hostent     *hp;

    char   rbuf[1024];
    int    nbytes = 1;

    fd_set rfds;       /* select() で用いるファイル記述子集合 */
    struct timeval tv; /* select() が返ってくるまでの待ち時間を指定する変数 */

    /* シグナルハンドラを設定 */
    if(signal(SIGALRM,timeout) == SIG_ERR) {
        perror("signal failed.");
        exit(1);
    }

    /* ソケットの生成 */
    if ((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))<0) {
        perror("socket");
        exit(1);
    }

    /* host(ソケットの接続先) の情報設定 */
    bzero(&host,sizeof(host));
    host.sin_family=AF_INET;
    host.sin_addr.s_addr=htonl(INADDR_ANY);
    host.sin_port=htons(10130);

    /* IPアドレスの取得 */
    if ( ( hp = gethostbyname(argv[1]) ) == NULL ) {
        fprintf(stderr,"unknown host %s\n",argv[1]);
        exit(2);
    }
    bcopy(hp->h_addr,&host.sin_addr,hp->h_length);

    /* ホストに接続 */
    if (connect(sock, (struct sockaddr*)&host, sizeof(host)) < 0) {
        perror("connect");
        exit(3);
    } else {
        printf("Connected to [%s]\n", hp->h_name);
    }

    /* タイマーを設定 */
    myalarm(TIMEOUT);

    do{
        /* 入力を監視するファイル記述子の集合を変数 rfds にセットする */
        FD_ZERO(&rfds);     /* rfds を空集合に初期化 */
        FD_SET(0,&rfds);    /* 標準入力 */
        FD_SET(sock,&rfds); /* 作成したソケット */

        /* 監視する待ち時間を 1 秒に設定 */
        tv.tv_sec  = 1;
        tv.tv_usec = 0;

        /* 標準入力とソケットからの受信を同時に監視する */
        if(select(sock+1,&rfds,NULL,NULL,&tv)>0) {

            /* タイマーを再設定 */
            myalarm(TIMEOUT);

            if(FD_ISSET(0,&rfds)) { /* 標準入力から入力があったなら */
                /* 標準入力から読み込みサーバーに送信 */
                if ((nbytes = read(0, rbuf, sizeof(rbuf))) < 0) {
                    perror("send");
                } else {
                    write(1, "client ", 7);
                    write(1, rbuf, nbytes);
                    write(sock, rbuf, nbytes);
                }
            }

            if(FD_ISSET(sock,&rfds)) { /* ソケットから受信したなら */
                /* ソケットから読み込み端末に出力 */
                if ((nbytes = read(sock, rbuf, sizeof(rbuf))) < 0) {
                    perror("read");
                } else {
                    write(1, hp->h_name, strlen(hp->h_name));
                    write(1, rbuf, nbytes);
                }
            }
        }

        /* タイムアウト処理 */
        if(timeoutFlag == 1) {
            printf("TimeOut!\n");
            write(sock, "", 0);
            close(sock);
            exit(0);
        }

    } while (nbytes != 0);

    close(sock);
    printf("closed\n");

}
